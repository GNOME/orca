<!-- Copyright 2005, Sun Microsystems, Inc. -->

<book>
  <title>Orca Architecture and Functional Specification</title>
  <bookinfo>
    &legal;
  </bookinfo>


  <!--
  ************************************************************************
  *                                                                      *
  * FORWARD                                                              *
  *                                                                      *
  ************************************************************************
  -->

  <preface><title>Foreword</title>
    &blurb;
    <para>This book covers the architecture and functional
      specification of Orca.  The specification was driven primarily
      by the Orca User Experience Design.
    </para>
  </preface>


  <!--
  ************************************************************************
  *                                                                      *
  * INTRODUCTION                                                         *
  *                                                                      *
  ************************************************************************
  -->

  <chapter><title>Introduction</title>

    <para>The Orca architecture has been driven primarily by the Orca
      User Experience Design.  There are two primary operating modes
      of Orca: a focus tracking mode and a flat review mode.</para>

    <para>The focus tracking mode generally relies upon applications
      to provide reasonable keyboard navigation techniques to allow
      the user to operate the application without requiring the mouse.
      As the user uses traditional keyboard navigation techniques to
      move from component to component in the application (e.g.,
      pressing the Tab key to move from pushbutton to text area to
      toggle button, etc.), Orca will present this to the user via
      braille, speech, magnification, or a combination thereof.  In
      the cases where more complex navigation is needed, such as
      structural navigation of complex text documents, Orca also
      provides a facility to define keyboard and braille input events
      that it can intercept and handle appropriately.</para>

    <para>The flat review mode provides the user with the ability to
      spatially navigate a window, giving them the ability to explore
      as well as discover and interact with components in the window.
      Orca provides a default set of keybindings for flat review, and
      these keybindings can be easily redefined by the user.</para>

    <para>The various modes of Orca are handled by "scripts," which
      are Python modules that can provide a custom interpretation of
      an application's interaction model.  It is not intended that 
      there will be a unique script for every application.  Instead,
      it is expected that there will be a general purpose script that
      covers a large number of applications.  In the event that more
      compelling or custom behavior is desired for an application,
      however, one can use a custom script for the application.
      Furthermore, scripts can subclass other scripts, allowing
      them to be quite simple.</para>
  </chapter>


  <!--
  ************************************************************************
  *                                                                      *
  * INFRASTRUCTURE SUPPORT                                               *
  *                                                                      *
  ************************************************************************
  -->

  <chapter><title>Prerequisites</title>
    <para>To help narrow the scope of the Orca development activity,
      Orca uses existing software where available.  For example, as
      mentioned in the requirements, Orca is a screen reader that
      needs to be able to interact with speech synthesis, braille,
      and screen magnification services, but it need not be the
      provider of such services.  Given this, Orca has the following
      dependencies:</para>

    <section><title>Python v2.4 or better</title> 
      <para>Orca is written in the Python programming language and
        depends upon features found in Python versions 2.4 and
        greater.</para>
    </section>

    <section><title>pyorbit v2.0.0 or better</title> 
      <para>PyORBit provides the Python language bindings for ORBit,
        which is Bonobo's CORBA ORB implementation.</para>
    </section>

    <section><title>libbonobo v2.0.0 or better</title> 
      <para>libbonobo provides the Python language bindings for Bonobo,
        which gives Orca access to the AT-SPI.</para>
    </section>

    <section><title>gnome-python-2.0 v2.6.0 or better</title> 
      <para>GNOME-Python provides the Python language bindings for the
        GNOME libraries.</para>
    </section>

    <section><title>pygtk-2.0 v2.4.0 or better</title> 
      <para>PyGTK provides a convenient wrapper for the GTK library
        for use in Python programs, and takes care of many of the
        details such as managing memory and type casting. When
        combined with PyORBit and gnome-python, it can be used to
        write full featured Gnome applications.</para>
    </section>

    <section><title>AT-SPI v1.6.6 or better</title>
      <para> Orca's means of gathering information about the desktop
        as well interacting with the desktop will be done through
        the AT-SPI <citation><xref linkend="at-spi"
        endterm="at-spi.abbrev"/></citation>.  As such, a
        functioning AT-SPI environment is mandatory.  The AT-SPI
        provides a CORBA-based approach to detect, examine, and
        manipulate desktop and application content.  It supports the
        registration of event listeners for changes to desktop and
        application content.  Finally, the AT-SPI supports the
        registration of listeners for input device events, with an
        option for these listeners to intercept (and possibly
        consume) the events before they are processed by the desktop
        or applications on the desktop.</para>
    </section>

    <section><title>gnome-speech v0.3.9 or better</title>
      <para>GNOME-Speech <citation><xref linkend="gnome-speech"
      endterm="gnome-speech.abbrev"/></citation> provides a
      CORBA-based approach to access speech synthesizers as network
      services.</para>
    </section>

    <section><title>BrlTTY v3.6.1 or better</title>
      <para>BrlTTY <citation><xref linkend="brltty"
        endterm="brltty.abbrev"/></citation> provides access to a
        variety of Braille displays, and consists of a library and a
        daemon to provide programmatic interaction with the
        display.</para>
    </section>

    <section><title>gnome-mag v0.11.11 or better</title>
      <para>GNOME-mag <citation><xref linkend="gnome-mag"
      endterm="gnome-mag.abbrev"/></citation> provides a CORBA-based
      approach to access and manipulate a screen magnifier as a
      network service.</para>
    </section>

    <section><title>Keyboard Navigation</title>
      <para>As much as possible, Orca relies upon the keyboard
        navigation methods built in to the native platform.  For
        example, it is expected that the native platform will provide
        access via traditional methods such as the "tab" key, keyboard
        mnemonics, and keyboard accelerators.</para>
    </section>
  </chapter>


  <!--
  ************************************************************************
  *                                                                      *
  * ARCHITECTURE                                                         *
  *                                                                      *
  ************************************************************************
  -->

  <chapter id="architecture"><title>Architecture and Implementation</title>

    <para>As illustrated in the high level Orca architecture diagram,
      the main components of Orca are as follows: desktop applications
      that support the AT-SPI, the AT-SPI registry and infrastructure,
      Orca itself, Orca Scripts, and system services (e.g., speech,
      braille, magnification).</para>

    <figure>
      <title>High Level Orca Architecture. The main components of Orca
        are as follows: desktop  applications that support the AT-SPI,
        the  AT-SPI  registry and  infrastructure,  Orca itself,  Orca
        Scripts, and  system services.  The  key communication between
        the components is depicted.</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="architecture.jpg" format="JPEG">
        </imageobject>
        <textobject>
          <phrase>High Level Orca Architecture</phrase>
        </textobject>
      </mediaobject>      
    </figure>

    <para>The following sections describe the architecture in more
      detail.</para>

    <section><title>Desktop and AT-SPI</title>

      <para>Orca's sole view of any application on the desktop is via
        the AT-SPI <citation><xref linkend="at-spi"
        endterm="at-spi.abbrev"/></citation>.  The AT-SPI is a
        CORBA/Bonobo-based technology <citation><xref linkend="bonobo"
        endterm="bonobo.abbrev"/></citation> that provides a common
        interface for the desktop and its applications to expose their
        GUI component hierarchy to assistive technologies such as
        Orca.  AT-SPI support is provided by toolkits such as GNOME's
        GTK+ toolkit (via gail <citation><xref linkend="gail"
        endterm="gail.abbrev"/></citation>), the Java platform (via
        the Java access bridge &todo; get link), and the custom
        toolkits used by applications such as Mozilla and Open
        Office.</para>

      <para>Assistive Technologies interact with the AT-SPI via two
        primary means: the AT-SPI registry and accessible objects.
        The AT-SPI registry permits assistive technologies to discover
        existing applications on the desktop and to register for event
        notification for AT-SPI events (e.g., window creation, focus
        changes, object state changes, etc.) and device events (e.g.,
        keyboard input events).  Accessible objects provide the
        assistive technology with information about the application,
        and tend to mirror the actual GUI component hierarchy.
        Accessible objects can be obtained in three ways: </para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>From the AT-SPI registry via queries on the desktop</para>
        </listitem>
        <listitem>
          <para>From an AT-SPI event</para>
        </listitem>
        <listitem>
          <para>From another Accessible via parent/child relationships
            and other relationships</para>
        </listitem>
      </orderedlist>

      <para>Orca's interaction with the AT-SPI is managed through
        Orca's <literal>atspi.py</literal> module.  The
        <literal>atspi.py</literal> module communicates directly with
        the AT-SPI via the AT-SPI IDL interfaces and also provides a
        number of classes that help with AT-SPI interaction:
        <literal>Registry</literal>, <literal>Accessible</literal>,
        and <literal>Event</literal>.  The full documentation for
        each of these classes is available in the pydoc for Orca, 
        and the following paragraphs provide a brief overview.</para>

      <para>The <literal>Registry</literal> class provides a singleton
        (actually a "Borg") class instance to access to the AT-SPI
        registry.  It provides convenience methods for registering
        AT-SPI event listeners and device event listeners, and also
        provides the mechanism for starting and stopping event
        delivery from the AT-SPI registry.</para>

      <para>The <literal>Accessible</literal> class provides a wrapper
        for communicating with CORBA objects that implement the AT-SPI
        Accessible and Application interfaces. Using Python's ability
        to add new properties to a class instance at run time, Orca
        can also annotate Accessible class instances with additional
        information.  The main purpose of an Accessible is to provide
        a local cache for accessible objects, preventing the need for
        numerous round trip calls to the AT-SPI registry and
        application for information.</para>

      <para>The <literal>Event</literal> class provides a wrapper for
        converting AT-SPI events into Python <literal>Event</literal>
        instances.  The main purpose is to convert the AT-SPI
        accessible source of the event into a Python
        <literal>Accessible</literal> instance and to also provide an
        <literal>Event</literal> instance that can be annotated by
        scripts (the AT-SPI event is read-only).</para>

      <para>As illustrated in the high level Orca architecture
        diagram, the <literal>atspi</literal> module has been used to
        register event and device listeners with the AT-SPI registry.
        Each exemplary desktop application (Firefox, NetBeans, GAIM,
        StarOffice) emits AT-SPI events to the AT-SPI registry which
        then delivers them to the <literal>atspi</literal> module.
        The <literal>atspi</literal> module then calls all appropriate
        listeners for the events it receives from the AT-SPI
        registry.</para>

      <para>In this case, the <literal>orca</literal> module receives
        keyboard events, which it interprets and also sends on to the
        <literal>focus_tracking_presenter</literal> module.  Of more
        interest, however, is that the
        <literal>focus_tracking_presenter</literal> module receives
        AT-SPI events which it then passes on the script for the
        application associated with the event.  If there is no script,
        the <literal>focus_tracking_presenter</literal> will create
        one.  See the &script_guide_link; for more information.</para>

      <para>The <literal>atspi</literal> module also registers its
        own set of event listeners that it uses to keep its local
        cache of accessible objects up to date.</para>

      <para>&detail; Because processing AT-SPI object events can be
        time consuming, and because the notification of AT-SPI object
        events is relatively "bursty," the
        <literal>focus_tracking_presenter</literal> maintains a queue
        of AT-SPI object events. It adds the events to this queue when
        it receives them and processes the events on the GLib idle
        handling thread.  This permits Orca to survive a relatively
        long burst of events and also allows it to handle the events
        on a thread that is compatible with GLib.</para>

      <para>&detail; Unlike AT-SPI object events, Orca must process
        keyboard events immediately and quickly because it needs to
        determine if it should consume those events or not.  As such,
        the <literal>atspi</literal> component will dispatch keyboard
        events directly to the keyboard event listeners registered by
        Orca.</para>

      <para> &todo; The system needs to be able to cope with failure.
        Right now, if Orca fails while handling a keyboard event, the
        whole desktop can hang.  I'm curious if the AT-SPI-enabled app
        can heal when the connection to Orca is broken or if there is
        a timeout?  Conversations with Bill Haneman lead me to believe
        there is no such thing as a timeout for the synchronous form
        of device event notification.</para>
    </section>

    <section><title>Orca</title>

      <para>The <literal>orca</literal> module is the "main entry
        point" of Orca.  It initializes the components that Orca uses
        (atspi, speech, braille, mag) and loads the user's settings.
        It also is the first to receive all keyboard and braille input
        events and delves them out to other Orca components
        appropriately.</para>

      <para>The <literal>orca</literal> module maintains the current
        known "locus of focus" in its <literal>locusOfFocus</literal>
        field that is set via the <literal>setLocusOfFocus</literal>
        method.  This locus of focus represents the current object
        that effectively has keyboard focus.  That is, the object that
        will change and or react to keyboard input events.  Orca
        scripts call this method to inform Orca when the locus of
        focus has changed.  In addition, in the event that there was
        a visual appearance change to the object that has the locus
        of focus, the <literal>orca</literal> module provides a
        <literal>visualAppearanceChanged</literal> that scripts can
        use to inform Orca of this event.</para>

      <para>The <literal>orca</literal> module also maintains a list
        of all known applications.  This list is available as the
        <literal>apps</literal> field.</para>

      <section><title>settings</title> 
        <para>The <emphasis role="bold">settings</emphasis> module
          (not depicted in the high level Orca architecture diagram)
          holds preferences set by the user during configuration.
          These settings include the following: use of speech and/or
          braille, voice styles, key echo, text echo, and command echo
          (see the &user_requirements_link; for details on these
          features).</para>

        <para>Any Orca module can request the value of a setting by
          calling the <literal>getSetting</literal> method of the
          <literal>settings</literal> module.  When first called, this
          module will import the <literal>user-settings</literal>
          module from the <literal>~/.orca directory</literal>, if it
          exists.  The <literal>user-settings</literal> module is a
          Python script, allowing it to contain functions, class
          definitions, etc.  Furthermore, the import of the
          <literal>user-settings</literal> module will cause any
          executable statements to be run, allowing the module to
          define/set fields in itself and call functions in other
          modules.  For example, the module will typically define the
          use of output mode (speech, braille, mag) and may also call
          functions in other modules, such as the
          <literal>setDebugLevel</literal> method of the
          <literal>debug</literal> module.</para>

         <para>The <literal>getSetting</literal> method of the
           <literal>settings</literal> module is intended to discover
           field attribute values.  It will first look to the
           <literal>user-settings</literal> module for the field, and
           then fall back to the <literal>settings</literal> module.
           The <literal>getSetting</literal> method also accepts a
           default value in the event the field does not exist in
           either the <literal>user-settings</literal> or
           <literal>settings</literal> module.</para> 

         <para>&detail; the <literal>init</literal> method of the
           <literal>orca</literal> module obtains settings.  As a
           result, the <literal>user-settings</literal> module is
           imported very early in the Orca life cycle.</para>

      </section>
    </section>

    <section id="script"><title>Orca Scripts</title>

      <para>Internally, the <literal>orca</literal> module keeps track
        of list of <literal>PresentationManager</literal> instances
        (see the pydoc for
        <literal>presentation_manager.py</literal>). The
        <literal>FocusTrackingPresenter</literal> (see
        <literal>focus_tracking_presenter</literal>) is of the most
        interest, as it is the <literal>PresentationManager</literal>
        that manages scripts.</para>

      <para>Details on the <literal>FocusTrackingPresenter</literal>
        and Orca scripts can be found in the
        &script_guide_link;.</para>

    </section>

    <section><title>System Services</title>

      <para> Orca relies on existing system services to provide
        support for speech synthesis, braille, and screen
        magnification.  To interact with these services, Orca provides
        the modules described in the following sections.
      </para>

      <section><title>speech</title>

        <para>The <emphasis role="bold">speech</emphasis> module
          provides Orca's Python interface to system speech services.
          Each speech service is generated by a "speech server
          factory."  There are currently two such factories: one for
          <citation><xref linkend="gnome-speech"
          endterm="gnome-speech.abbrev"/></citation> (see
          <literal>gnomespeechfactory.py</literal> and one for
          <citation><xref linkend="emacspeak"
          endterm="emacspeak.abbrev"/></citation> (see
          <literal>espeechfactory.py</literal>), though it is expected
          that support for other factories can be added in the
          future.</para>
          
        <para>Each speech factory offers up a list of
          <literal>SpeechServer</literal>s, where each
          <literal>SpeechServer</literal> is typically an interface to
          a particular speech engine.  For example, the
          <literal>espeechfactory</literal> will offer up a
          <literal>SpeechServer</literal> that talks to the Fonix
          DECtalk engine and a <literal>SpeechServer</literal> that
          talks to the IBMTTS engine.  Likewise, the
          <literal>gnomespeechfactory</literal> will offer up a
          <literal>SpeechServer</literal> that uses the
          <literal>gnome-speech</literal> interface to talk to the
          Festival Speech Synthesis System, a separate
          <literal>SpeechServer</literal> that also uses the
          <literal>gnome-speech</literal> interface to talk to the
          Fonix DECtalk engine, and so on.</para>

        <para>Each <literal>SpeechServer</literal> instance then provides
          a set of methods for actually speaking.  Each of the methods
          accepts an <literal>ACSS</literal> instance, which represents
          an aural cascading style sheet (<citation><xref linkend="acss"
          endterm="acss.abbrev"/></citation>) that defines the voice
          and voice parameter settings to use.</para>

        <para>As part of the <literal>orca-setup</literal> process,
          the user selects a particular speech factory,
          <literal>SpeechServer</literal>, and voice to use as their
          default voice.  When Orca starts, the
          <literal>speech</literal> module looks for these settings
          and connects to the appropriate speech factory and
          <literal>SpeechServer</literal>.  In the event the a
          connection cannot be made, the <literal>speech</literal>
          module attempts to find a working synthesis engine to use by
          examining its list of speech factories.  The
          <literal>speech</literal> module then provides simple
          methods that delegate to the <literal>SpeechServer</literal>
          instance.  This model allows scripts to use their own
          <literal>SpeechServer</literal> instances if they wish, but
          to also just rely upon the user's default
          preferences.</para>
      </section>

      <section><title>braille</title>
        <para> The <emphasis role="bold">braille</emphasis> module
          provides Orca's Python interface to the system's BrlTTY
          <citation><xref linkend="brltty"
          endterm="brltty.abbrev"/></citation> daemon.  The BrlTTY
          daemon, in turn, provides the interface to braille devices
          for both displaying braille and receiving input from the
          user.</para>
        <para>&todo; flesh this section out more.</para>
      </section>

      <section><title>mag</title>
        <para> The <emphasis role="bold">mag</emphasis> module
          provides Orca's Python interface to the system's gnome-mag
          <citation><xref linkend="gnome-mag"
          endterm="gnome-mag.abbrev"/></citation> CORBA service(s).
          The magnification component provides methods that permit
          Orca discover screen magnification services and set their
          desktop region of interest.</para>
        <para>&todo; flesh this section out more.</para>
      </section>

    </section>

  </chapter>


  <!--
  ************************************************************************
  *                                                                      *
  * I18N SUPPORT                                                         *
  *                                                                      *
  ************************************************************************
  -->

  <chapter><title>Internationalization (I18N) Support</title>
    <para>All human-consumable text obtained from AT-SPI calls is
      expected to be in a localized form.  As such, Orca does not
      do any extra localization processing when working with text
      obtained via the AT-SPI.</para>
    <para>For text generated by Orca itself, Orca handles
      internationalization and localization using the <citation><xref
      linkend="gettext" endterm="gettext.abbrev"/></citation> support
      of Python.  The gettext support of Python is similar to the GNU
      gettext module.  Each human consumable string of Orca is US
      English text wrapped in a call to gettext.gettext.  The call to
      gettext.gettext will either return a localized string or default
      to the US English text. Orca depends upon an active and thriving
      community of open source translators to provide the
      localizations.</para>
    <para>The synthesis of localized speech is to be provided by the
      underlying gnome-speech implementation.</para>
    <para>The generation of localized braille is to be determined.
      &todo; BrlTTY currently does not support this at the moment, but
      it is expected that the BrlTTY developers will add this in the
      future.</para>
  </chapter>

  <!--
  ************************************************************************
  *                                                                      *
  * BIBLIOGRAPHY                                                         *
  *                                                                      *
  ************************************************************************
  -->

  <bibliography>
    <biblioentry role="unpublished" id="at-spi">
      <abbrev id="at-spi.abbrev">AT-SPI</abbrev>
      <authorgroup>
        <author><firstname>Bill</firstname><surname>Haneman</surname></author>
        <author><firstname>Marc</firstname><surname>Mulcahy</surname></author>
        <author><firstname>Michael</firstname><surname>Meeks</surname></author>
      </authorgroup>
      <title><ulink url="http://directory.fsf.org/accessibility/at-spi.html">
        AT-SPI</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="acss">
      <abbrev id="acss.abbrev">ACSS</abbrev>
      <authorgroup>
        <author><firstname>T.V.</firstname><surname>Raman</surname></author>
      </authorgroup>
      <title><ulink url="http://www.w3.org/TR/1998/REC-CSS2-19980512/aural.html">Aural Style Sheets</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="bonobo">
      <abbrev id="bonobo.abbrev">Bonobo</abbrev>
      <author><firstname>George</firstname><surname>Lebl</surname></author>
      <title><ulink url="http://lidn.sourceforge.net/articles/gnomenclatureintrotobonobo/">
        Gnomenclature: Intro to bonobo</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="brltty">
      <abbrev id="brltty.abbrev">BRLTTY</abbrev>
      <authorgroup>
        <author><firstname>Dave</firstname><surname>Meilke</surname></author>
        <author><firstname>Nicolas</firstname><surname>Pitre</surname></author>
        <author><firstname>Stephane</firstname><surname>Doyon</surname></author>
      </authorgroup>
      <title><ulink url="http://directory.fsf.org/accessibility/brltty.html">
        BRLTTY</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="emacspeak">
      <abbrev id="emacspeak.abbrev">Emacspeak</abbrev>
      <authorgroup>
        <author><firstname>T.V.</firstname><surname>Raman</surname></author>
      </authorgroup>
      <title><ulink url="http://emacspeak.sourceforge.net/">Emacspeak</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="gail">
      <abbrev id="gail.abbrev">GAIL</abbrev>
      <author><firstname>Bill</firstname><surname>Haneman</surname></author>
      <title><ulink url="http://freshmeat.net/projects/gail/">
        GAIL</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="gettext">
      <abbrev id="gettext.abbrev">gettext</abbrev>
      <author><surname>&todo; Unknown</surname></author>
      <title><ulink url="http://docs.python.org/lib/module-gettext.html">
        gettext</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="gnome-mag">
      <abbrev id="gnome-mag.abbrev">Gnome-Mag</abbrev>
      <author><firstname>Bill</firstname><surname>Haneman</surname></author>
      <title><ulink url="http://directory.fsf.org/accessibility/gnome-mag.html">
        Gnome-Mag</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="gnome-speech">
      <abbrev id="gnome-speech.abbrev">Gnome-Speech</abbrev>
      <authorgroup>
        <author><firstname>Marc</firstname><surname>Mulcahy</surname></author>
        <author><firstname>Michael</firstname><surname>Meeks</surname></author>
      </authorgroup>
      <title><ulink url="http://directory.fsf.org/accessibility/gnome-speech.html">
        Gnome-Speech</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="gnopernicus">
      <abbrev id="gnopernicus.abbrev">Gnopernicus</abbrev>
      <author><firstname>Remus</firstname><surname>Draica</surname></author>
      <title><ulink url="http://directory.fsf.org/accessibility/gnopernicus.html">
        Gnopernicus</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="jaws">
      <abbrev id="jaws.abbrev">JAWS</abbrev>
      <author><firstname></firstname><surname>Freedom Scientific</surname></author>
      <title><ulink url="http://www.freedomscientific.com/fsproducts/softwarejaws.asp">
        JAWS</ulink>
    </title>
    </biblioentry>

    <biblioentry role="unpublished" id="xkb">
      <abbrev id="xkb.abbrev">XKB</abbrev>
      <authorgroup>
        <author><firstname>Erik</firstname><surname>Fortune</surname></author>
        <author><firstname>William</firstname><surname>Walker</surname></author>
        <author><firstname>Donna</firstname><surname>Converse</surname></author>
        <author><firstname>George</firstname><surname>Sachs</surname></author>
      </authorgroup>
      <title><ulink url="http://matrix.netsoc.tcd.ie/hcksplat/work/XKBlib.pdf">
        The XKB keyboard extension</ulink>
    </title>
    </biblioentry>
  </bibliography>

</book>
