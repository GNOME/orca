<!-- Copyright 2005-2008, Sun Microsystems, Inc. -->

  <!--
  ************************************************************************
  *                                                                      *
  * INTRODUCTION                                                         *
  *                                                                      *
  ************************************************************************
  -->

  <chapter id="scriptguide"><title>Introduction to Scripting</title>
    <para>The goal of scripting is to provide Orca with the capability
    of providing a natural feeling and compelling user experience for
    the various user interaction models of different desktop
    applications.</para>

    <para>The Orca scripting approach allows scripts to extend and/or
    override the behavior of other scripts, thus simplifying the job
    of a script writer.  To further facilitate script writing, Orca
    provides a "default" script (held in
    the <literal>orca.default.Script</literal> class) that provides a
    reasonable default behavior for Orca.  This will not only serve as
    the "fallback script" for Orca, but will also typically serve as
    the "jumping off" point for writing custom scripts.  Furthermore,
    keep in mind that the "default" script is intended to cover a
    large variety of applications.  As such, you may find that it is
    not necessary to write a custom script.</para>

    <para>The primary and preferred operating mode of Orca is "focus
    tracking mode," where Orca keeps track of the most relevant user
    interface object that has keyboard focus.  When Orca detects
    changes to this object, which Orca refers to as the "locus of
    focus," (available as
    the <literal>orca.orca_state.locusOfFocus</literal> field and set via
    the <literal>orca.orca.setLocusOfFocus</literal> method) Orca will
    present relevant information to the user.</para>

    <para>As such, the primary goal of a script is to assist Orca in
    tracking of the locus of focus as well as presenting information
    about the locus of focus.  A script does this by registering for
    one or more AT-SPI events and then reacting appropriately when it
    receives those events.  A script can also intercept and interpret
    keystrokes and braille input events, allowing it to further extend
    the behavior of Orca.</para>

    <section id="sgcontract"><title>Script Contract</title>
      <para>The contract for a script is documented in detail in the
      pydoc of the <literal>orca.script.Script</literal> class in the
      <literal>orca/script.py</literal> module.  The
      <literal>orca.default.Script</literal> subclass defined in the
      <literal>orca/default.py</literal> module provides the default
      behavior for Orca when it encounters applications and toolkits
      that behave like the GTK toolkit.  It is expected that new
      scripts will typically extend
      the <literal>orca.default.Script</literal> subclass rather than
      directly extending the <literal>orca.script.Script</literal>
      class.</para>
    </section>

    <section id="sglifecycle"><title>Script Life Cycle</title>
     <section id="birth"><title>Birth</title>
      <para>Orca's <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
      class is the sole maintainer of scripts. Whenever it receives
      an event from the AT-SPI Registry, the
      <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
      class instance will determine the application associated with
      that event and create a new script for that application if on
      has not yet been created.  A single
      <literal>orca.script.Script</literal> instance will be created for each
      application instance on the desktop.  For example, if two
      instances of <literal>gcalctool</literal> are running, the 
      <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
      class instance will create a
      <literal>orca.script.Script</literal> instance for
      each <literal>gcalctool</literal> it encounters.</para>

      <para>The script creation process consists of the following
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>The <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class tries to find the script for an application in the
          following order, using whichever it finds first:</para>

          <orderedlist numeration="arabic">
            <listitem>
              <para>a script based upon the application name</para>
            </listitem>
            <listitem>
              <para>a script based upon the toolkit name of the application</para>
            </listitem>
            <listitem>
              <para>the <literal>orca.default.Script</literal> script</para>
            </listitem>
          </orderedlist>

          <para>The application scripts live in
          the <literal>orca.scripts.apps</literal> package, the
          toolkit scripts live in
          the <literal>orca.scripts.toolkits</literal> package, and
          the <literal>orca.default.Script</literal> class lives in
          the <literal>orca/default.py</literal> module.</para>

          <para>The application name is available as
          the <literal>name</literal> field of the application, which
          can be obtained from the
          <literal>host_application</literal> field of an event or
          the <literal>getApplication</literal> method of an accessible
	  object.</para>

	  <para>Rather than using the application name directly,
	  however, the
	  <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal> class uses
	  the <literal>orca.settings.getScriptModuleName</literal> method.
	  This method provides a convenience mechanism to map an
	  application name to a script module name, allowing the
	  mapping of names containing illegal module name characters
	  as well as the mapping of names for applications that
	  frequently change their name.  By default, the method just
	  uses application name for the module name, but the behavior
	  can be overridden using
	  the <literal>orca.settings.setScriptMapping</literal>
	  method.  For example, the application name of "gcalctool"
	  can be directly mapped
	  to <literal>orca/scripts/apps/gcalctool.py</literal> whereas
	  the application names of "Bon Echo", "Minefield",
	  "Shiretoko", "Firefox", and whatever other personalities the
	  Firefox web browser chooses to emit will be mapped to
	  the <literal>orca/scripts/apps/Mozilla.py</literal>
	  module via calls to <literal>setScriptMapping</literal>
          by the <literal>orca.settings</literal> module itself.</para>

          <para>If a custom script is not available for the specific
          application,
          the <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class will search for a toolkit script using
          the <literal>toolkitName</literal> of the
          application.</para>

          <para>Failing the existence of an application-specific or
          toolkit-specific script,
          the <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal> class
          will create an instance of
          the <literal>orca.default.Script</literal> class defined in
          the <literal>orca/default.py</literal> module.</para>
 
          <para>For example, for the <literal>gnome-terminal</literal>
          application, the
          <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal> will look for
          the <literal>gnome-terminal.py</literal> in the
          <literal>orca.scripts.apps</literal> package.  If it cannot
          find such a module in the Python search path, the
          <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class will then check in
          the <literal>orca.scripts.toolkits</literal> package for a
          module matching the <literal>toolkitName</literal> of the
          application.  Failing that, Orca will create an instance of
          the
          <literal>orca.default.Script</literal> class defined in the
          <literal>orca/default.py</literal> module.</para>

          <para>&detail; it is possible to tell Orca to bypass all
          custom script creation by setting
          <literal>orca.settings.enableCustomScripts=False</literal>
          in your <literal>~/.orca/user-settings.py</literal>
          or <literal>~/.orca/orca-customizations.py</literal>
          modules.  This can be useful for debugging purposes.</para>
        </listitem>

        <listitem>
          <para>Each script module is expected to define a
          <literal>Script</literal> class that ultimately extends
          the <literal>orca.Script</literal> class defined in the
          <literal>orca/script.py</literal> module.  The constructor
          takes the accessible application object as an
          argument.</para>

          <para>The constructor for the <literal>Script</literal>
          instance is expected to define any keystrokes, braille
          buttons, and AT-SPI event listeners it is interested in
          (see the <link linkend="customization">Customized
          Behavior</link> section for how to do this).</para>
        </listitem>

        <listitem>
          <para>Once it has created a script, the
            <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
            class will register event listeners for all AT-SPI events
            associated with script (i.e., the script should not
            register these events itself).  When the
            <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
            class receives an event, it will pass the event to the
            script instance associated with the event, regardless if
            the application associated with the script has focus or
            not.</para>

          <para>&detail; the
          <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class registers its own <literal>_enqueueEvent</literal>
          method as the main AT-SPI event listener for all of Orca.
          This method finds (and creates if necessary) the script
          associated with the event and passes the event onto the
          required
          <literal>processObjectEvent</literal> method of the script
          for processing.  The event is an instance of
          the <literal>pyatspi.Event</literal> class.  You should
          become familiar with AT-SPI and <literal>pyatspi</literal>
          if you plan on becoming a script writer for Orca.  Training
          and documentation of those projects are out of the scope of
          this document; you should refer to the documentation of
          those projects to learn more about them. &todo; provide
          reference to pyatspi.</para>
        </listitem>
        <listitem>
          <para>The <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class also keeps track of the active script, as determined
          by the script associated with the currently active window,
          and will pass all keyboard and braille input events to the
          active script.  Thus, while all other types of events go to
          the script for the application which generated the event,
          all input devices events go to the active script.  The
          current active script can be found as
          <literal>orca.orca_state.activeScript</literal>.  When the
          <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          changes the active script, it calls
          the <literal>activate</literal> method of the new active
          script and the <literal>deactivate</literal> of the script
          that used to be the active script.  A script can also tell
	  if it is the active script by comparing the 
	  <literal>orca.orca_state.activeScript</literal> field to
	  itself.</para>

          <para>&detail; the
          <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class implements the
          <literal>processKeyboardEvent</literal> and
          <literal>processBrailleEvent</literal> methods which are
          called by the main <literal>orca.orca</literal> module
          whenever it receives a keystroke or braille input event.
          The
          <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class will pass these events onto the
          <literal>processKeyboardEvent</literal> and
          <literal>processBrailleEvent</literal> methods of the active
          script.</para>

          <para>&detail; Because processing AT-SPI object events can
          be time consuming, and because the notification of AT-SPI
          object events is relatively "bursty," the
          <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
          class maintains a queue of AT-SPI object and input device
          events. It adds the events to this queue when it receives
          them and processes the events on the GLib idle handling
          thread.  This permits Orca to survive a relatively long
          burst of events and also allows it to handle the events on a
          thread that is compatible with GLib.</para>
        </listitem>
      </itemizedlist>
     </section>

     <section id="birth"><title>Life</title>
      <para>Whenever
      the <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
      class sends a <literal>pyatspi.Event</literal> to a
      script's <literal>processObjectEvent</literal> method, the
      script can do whatever it wants.  Its primary task, however, is
      to assist Orca in keeping track of the locus of focus.  When a
      script detects a change in the locus of focus, it should call
      <literal>orca.orca.setLocusOfFocus</literal> with the
      <literal>pyatspi.Accessible</literal> object instance that is
      the new locus of focus.  Among other things, this results in
      the <literal>orca.orca_state.locusOfFocus</literal> field being
      updated.</para>

      <para>&note; The <literal>orca.orca_state.locusOfFocus</literal>
      field is intended to be set only via the
      <literal>orca.orca.setLocusOfFocus</literal> method. Because the
      <literal>orca.orca.setLocusOfFocus</literal> method performs bookkeeping
      and other tasks, the
      <literal>orca.orca_state.locusOfFocus</literal> field should never
      be set directly.</para>

      <para>&detail; The <literal>orca.orca</literal> module has logic to
      detect if the locus of focus really changed and will propagate
      the change as appropriate.  The
      <literal>orca.orca.setLocusOfFocus</literal> method first sends
      the change to the <literal>locusOfFocusChanged</literal> method
      of
      the <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
      class instance maintained in the <literal>orca.orca</literal>
      module, which then passes the change onto the required
      <literal>locusOfFocusChanged</literal> method of the active
      script. The <literal>locusOfFocusChanged</literal> method is the
      primary entry point where a script will present information to
      the user via speech and/or braille.</para>

      <para>In many cases, the locus of focus doesn't change, but some
      property of the current locus of focus changes.  For example,
      a checkbox is checked or unchecked, yet remains as the locus
      of focus.  In these cases, a script should also keep Orca
      informed by calling
      <literal>orca.orca.visualAppearanceChanged</literal>.</para>

      <para>&detail; Like
      the <literal>orca.orca.setLocusOfFocus</literal> method,
      the <literal>orca.orca.visualAppearanceChanged</literal> method
      will first call the
      <literal>orca.focus_tracking_presenter.FocusTrackingPresenter.visualAppearanceChanged</literal>
      method which will then call the
      required <literal>visualAppearanceChanged</literal> of the
      active script.  The
      <literal>visualAppearanceChanged</literal> is the primary place
      where a script will present such information to the user.</para>
     </section>

     <section id="birth"><title>Death</title>
      <para>Whenever the
      <literal>orca.focus_tracking_presenter.FocusTrackingPresenter._processObjectEvent</literal>
      method detects that an application has gone away (by determining
      that the application has been removed from the desktop), it will
      delete the script for that application and unregister any event
      listeners associated with that script.</para>
     </section>
    </section>
  </chapter>
    

  <!--
  ************************************************************************
  *                                                                      *
  * CUSTOMIZED BEHAVIOR                                                  *
  *                                                                      *
  ************************************************************************
  -->

  <chapter id="customization"><title>Customized Behavior</title>

    <para>The customized behavior of a script is set up in its
      constructor.  In its constructor, each script is expected to
      extend/override several fields as illustrated in the following
      diagram and describe below:</para>

    <figure>
      <title>Orca Script Diagram</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="script.jpg" format="JPEG"/>
          </imageobject>
          <textobject>
            <phrase>Orca Script Diagram</phrase>
          </textobject>
        </mediaobject>      
    </figure>

    <itemizedlist>
      <listitem>
        <para><literal>listeners</literal>: a dictionary where the
        keys are strings that match AT-SPI event types (e.g.,
        <literal>focus</literal>,
        <literal>object:text-caret-moved</literal>, etc.), and the
        values are functions to handle the event.  Each function is
        passed an <literal>pyatspi.Event</literal> instance as its
        sole parameter and no return value is expected (see the
        <link linkend="sgeventlisteners">Event Listeners</link> section
	for more information). The <literal>listeners</literal>
	dictionary is obtained by calling the
	script's <literal>getListeners</literal> method in the
	script's initializer method.  As such,
	the <literal>listeners</literal> field should never be
	modified except in the script's initializer.</para>
      </listitem>
      <listitem>
	<para><literal>inputEventHandlers</literal>: a dictionary where
	the keys are a machine readable handler name for use by the
        key and braille bindings and the values are instances of
        <literal>orca.input_event.InputEventHandler</literal> (see the
        <link linkend="sginputeventhandlers">Input Event Handlers</link>
	section for more information).</para>
      </listitem>
      <listitem>
        <para><literal>keyBindings</literal>: an instance of 
        <literal>orca.keybindings.KeyBindings</literal> (see
        the <literal>orca/keybindings.py</literal> module) that
        defines the keystrokes the script is interested in.
        The <literal>keyBindings</literal> field is obtained by
        calling the script's <literal>getKeyBindings</literal> method
        in the script's initializer method.  As such,
        the <literal>keyBindings</literal> field should never be
        modified except in the script's initializer.</para>
      </listitem>
      <listitem>
        <para><literal>brailleBindings</literal>: a dictionary where
        the keys are BrlTTY commands
        (e.g., <literal>CMD_HWINLT</literal>), and the values are
        <literal>orca.input_event.InputEventHandler</literal>
	instances.  The <literal>brailleBindings</literal> field is
	obtained by calling the
	script's <literal>getBrailleBindings</literal> method in the
	script's initializer method.  As such,
	the <literal>brailleBindings</literal> field should never be
	modified except in the script's initializer.</para>
      </listitem>
    </itemizedlist>

    <para>The constructor for the <literal>orca.script.Script</literal> class,
    which all scripts should ultimately extend (most will extend the
    <literal>orca.default.Script</literal> subclass of the <literal>orca/default.py</literal>
    module, which in turn extends
    <literal>orca.script.Script</literal> class of
    the <literal>orca/script.py</literal> module), calls the script
    methods to obtain these fields.  As such, a subclass merely needs
    to extend/override these methods.  Each of these methods is
    described in more detail in the following sections.</para>

    <section id="sgeventlisteners"><title>Event Listeners</title> 
      <para>Event listeners are what make Orca work.  Orca's main goal
      in life is to listen for AT-SPI events
      from <literal>pyatspi</literal> and then perform some action,
      such as speech and/or braille.</para>

      <para>&note; as a script writer, the majority of the "trickery"
      you will be doing is figuring out which event(s) you need to
      listen for in order to figure out what is happening in the
      application.  This is unfortunately and trial-and-error or
      trial-and-analyze operation.  The debug utilities of Orca, as
      described in the
      <link linkend="debug">Debug Utilities</link> section, provide
      you with tools to analyze the event traffic of an application.
      The <literal>accerciser</literal> application is also quite
      useful.  You should become familiar and comfortable with these
      tools.  Without an understanding of the object hierarchy or
      event traffic of an application, you will likely be unsuccessful
      as a script writer.</para>

      <para>As described above, the <literal>listeners</literal> field
      of a script is a dictionary where the keys are strings that
      match AT-SPI event types (e.g., <literal>focus</literal>,
      <literal>object:text-caret-moved</literal>, etc.), and the
      values are script functions to handle the event. A script's
      constructor can modify/extend this dictionary by merely creating
      a <literal>getListeners</literal> method that creates this
      dictionary and overrides or adds a new entry.  An example based
      upon the <literal>orca/scripts/apps/pidgin/script.py</literal> for
      the Pidgin application is as follows:</para>

<programlisting>
...
import orca.scripts.default as default
...
class Script(default.Script):
...
def getListeners(self):
    """Add in an AT-SPI event listener "object:children-changed:"
    events, for this script.
    """

    listeners = default.Script.getListeners(self)
    listeners["object:children-changed:"] = self.onChildrenChanged

    return listeners
...
</programlisting>

      <para>As described previously, the
      <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
      class will register listeners on behalf of a script, and will
      notify the script of any events via the script's
      <literal>processObjectEvent</literal> method.  The
      <literal>processObjectEvent</literal> method of the top level
      <literal>orca.script.Script</literal> class examines the
      <literal>event.type</literal> field of
      a <literal>pyatspi.Event</literal>, calling any matching
      functions from the <literal>listeners</literal> dictionary.  As
      such, it is unlikely that
      a <literal>orca.script.Script</literal> subclass will ever need
      to override the <literal>processObjectEvent</literal> method.
      Instead, it merely needs to populate the
      <literal>listeners</literal> dictionary as appropriate in
      a custom <literal>getListeners</literal> method.</para>

      <para>The function for an event listener merely takes an
      <literal>pyatspi.Event</literal> instance and does whatever it
      wants; the return value is ignored.  For example, the function
      definition associated with the above
      <literal>listeners</literal> entry might look like the
      following:</para>

<programlisting>
...
def onChildrenChanged(self, event):
    """Called whenever a child object changes in some way.

    Arguments:
    - event: the text inserted Event
    """

    # Check to see if a new chat room tab has been created and if it
    # has, then announce its name.
    #
    if event.type.startswith("object:children-changed:add"):
        rolesList = [pyatspi.ROLE_PAGE_TAB_LIST, \
                     pyatspi.ROLE_FILLER, \
                     pyatspi.ROLE_FRAME]
        if self.isDesiredFocusedItem(event.source, rolesList):
            # As it's possible to get this component hierarchy in other
            # places than the chat room (i.e. the Preferences dialog),
            # we check to see if the name of the frame is the same as one
            # of its children. If it is, then it's a chat room tab event.
            # For a final check, we only announce the new chat tab if the
            # last child has a name.
            #
            nameFound = False
            frameName = event.source.parent.parent.name
            for child in event.source:
                if frameName and (frameName == child.name):
                    nameFound = True
            if nameFound:
                child = event.source[-1]
                if child.name:
                    line = _("New chat tab %s") % child.name
                    speech.speak(line)
...
</programlisting>

      <para>As seen in this method, it is possible for an event handler
      to use speech and/or braille if it wants.  Usually,
      however, the <literal>locusOfFocusChanged</literal> and
      <literal>visualAppearanceChanged</literal> script methods should
      be reserved for those actions.</para>
    </section>

    <section id="sginputeventhandlers"><title>Input Event Handlers</title>
      <para>Input event handlers help define what Orca should do in
      response to keyboard or braille input events. Before describing
      how to set up keyboard and braille event handlers, it is import
      to first understand the
      <literal>orca.input_event.InputEventHandler</literal> class, which is defined in the
      <literal>orca/input_event.py</literal> module.</para>

      <para><literal>orca.input_event.InputEventHandler</literal>
      instances serve a purpose of holding a function to call for a
      particular input event, and a human consumable string that
      provides a short description of the function's behavior.  The
      main purpose of the
      <literal>orca.input_event.InputEventHandler</literal> is to
      provide support for the "learn mode" of Orca.  If learn mode is
      enabled, the input event handler will consume the input event
      (i.e., return <literal>True</literal>) and merely speak and
      braille the human consumable string. If learn mode is not
      enabled, the input event handler will pass the active script and
      the input event on to the function, returning the boolean value
      of the function as indication of whether the event should be
      consumed by Orca or passed on to the application.</para>

      <para>The input event handlers are held in
      the <literal>inputEventHandlers</literal> field of a script
      instance.  The <literal>inputEventHandlers</literal> field is a
      dictionary where the keys are a machine readable handler name
      for use by the key and braille bindings and the values are
      instances
      of <literal>orca.input_event.InputEventHandler</literal>.
      The <literal>inputEventHandlers</literal> is set up by the
      script's <literal>setupInputEventHandlers</literal> method.  As
      such, a script wishing to add new input event handlers or
      replace existing ones should define a
      new <literal>setupInputEventHandlers</literal> method.</para>

      <para>The best place to find examples of
      <literal>orca.input_event.InputEventHandler</literal> instances
      is in the <literal>setupInputEventHandlers</literal> method of
      the <literal>orca/default.py</literal> module.  Here's a reduced
      section of that specific method:</para>

<programlisting>
...
def setupInputEventHandlers(self):
    """Defines InputEventHandler fields for this script that can be
    called by the key and braille bindings."""

    self.inputEventHandlers["leftClickReviewItemHandler"] = \
        input_event.InputEventHandler(
            Script.leftClickReviewItem,
            # Translators: the 'flat review' feature of Orca
            # allows the blind user to explore the text in a
            # window in a 2D fashion.  That is, Orca treats all
            # the text from all objects in a window (e.g.,
            # buttons, labels, etc.) as a sequence of words in a
            # sequence of lines.  The flat review feature allows
            # the user to explore this text by the {previous,next}
            # {line,word,character}.  A left click means to generate
            # a left mouse button click on the current item.
            #
            _("Performs left click on current flat review item."))

    self.inputEventHandlers["rightClickReviewItemHandler"] = \
         input_event.InputEventHandler(
            Script.rightClickReviewItem,
            # Translators: the 'flat review' feature of Orca
            # allows the blind user to explore the text in a
            # window in a 2D fashion.  That is, Orca treats all
            # the text from all objects in a window (e.g.,
            # buttons, labels, etc.) as a sequence of words in a
            # sequence of lines.  The flat review feature allows
            # the user to explore this text by the {previous,next}
            # {line,word,character}.  A right click means to generate
            # a right mouse button click on the current item.
            #
            _("Performs right click on current flat review item."))
...
def leftClickReviewItem(self, inputEvent=None):
    """Performs a left mouse button click on the current item."""

    self.getFlatReviewContext().clickCurrent(1)
    return True

def rightClickReviewItem(self, inputEvent=None):
    """Performs a right mouse button click on the current item."""

    self.getFlatReviewContext().clickCurrent(3)
    return True
...
</programlisting>

      <para>In this
      definition, <literal>orca.default.script.Script.setupInputEventHandlers</literal>
      is creating a
      few <literal>orca.input_event.InputEventHandler</literal>
      instances that refer to script functions and a human consumable
      description of the input event.  &note; the functions return 
      <literal>True</literal> to indicate the input event should be
      "consumed", meaning it should only be used by Orca and not sent
      on to the GUI application that has keyboard focus.</para>

      <para>Now that the input event handlers are defined, the script
      can now bind keyboard and braille input events to them.</para>

    </section>

    <section id="sgkeybindings"><title>Keyboard Bindings</title>

      <para>Keyboard bindings are used to allow a script writer to
      take over a key combination for the purposes of controlling
      Orca.  For example, Orca provides bindings for obtaining
      information about the font attributes of text.</para>

      <para>The keyboard bindings for a script are held in the
      <literal>keyBindings</literal> field, which is a
      <literal>orca.keybindings.KeyBindings</literal> instance.  This
      field maintains a set
      of <literal>orca.keybindings.KeyBinding</literal>
      instances.</para>

      <para>Keyboard bindings merely define the keystroke, modifier,
      and key count circumstances needed to invoke an
      <literal>orca.input_event.InputEventHandler</literal> instance.
      This definition is held in
      a <literal>orca.keybindings.KeyBinding</literal> instance (see
      the <literal>orca/keybindings.py</literal> module).</para>

      <para>An example from <literal>orca/default.py</literal> that binds
      the numeric keypad 7 key to the
      <literal>reviewPreviousLine</literal> handler is as follows.
      &note; the string "reviewPreviousLineHandler" is what was
      used as the machine readable key when setting up the
      <literal>inputeventhandlers</literal> dictionary:</para>

<programlisting>
...
def getKeyBindings(self):
    """Defines the key bindings for this script.

       Returns an instance of keybindings.KeyBindings.
    """

    keyBindings = script.Script.getKeyBindings(self)
...
    keyBindings.add(
        keybindings.KeyBinding(
            "KP_7",
            settings.defaultModifierMask,
            settings.NO_MODIFIER_MASK,
            self.inputEventHandlers["reviewPreviousLineHandler"]))
...
    return keyBindings
</programlisting>

      <para>The first parameter of
      the <literal>orca.keybindings.KeyBinding</literal> constructor
      is a string that represents an X Window System KeySym string for
      the key.  This is typically a string from
      <literal>/usr/include/X11/keysymdef.h</literal> with the
      preceding 'XK_' removed (e.g., 'XK_KP_Enter' becomes the string
      'KP_Enter'), and is used as a means to express the physical
      key associated with the KeySym.</para>

      <para>The second parameter is a bit mask that defines which
      modifiers the keybinding cares about.  If it does not care about
      any modifier state, then this mask can be set to 0.  In general,
      it is best to define the list of modifiers the keybinding cares
      about so as to avoid conflicts among key bindings.  In the
      example above, the keybinding is being told to pay attention to
      the <literal>orca.settings.defaultModifierMask</literal>
      modifier mask, which is the set of all non-locking modifiers.
      Other masks might include
      the <literal>orca.settings.ORCA_MODIFIER_MASK</literal>, which
      is a modifier Orca sets when the <literal>Insert</literal> key
      is pressed when using the desktop layout.  See
      the <literal>orca/settings.py</literal> for other masks.</para>

      <para>The third parameter is a bit mask that defines what the
      modifier settings must be.  If a bit is set, it means the
      associated modifier must be set.  The only meaningful bits in
      this mask are those that are defined by the second
      parameter.  In the example above, the third parameter says 
      that none of the non-locking modifiers can be set.</para>

      <para>The fourth parameter is the
        <literal>orca.input_event.InputEventHandler</literal> to use
        if the user types a keystroke qualified by the previous
        parameters. The <literal>orca.input_event.InputEventHandler</literal>
        class is described in the previous section.</para>

      <para>The last parameter, whose value defaults to 1, is a click
      count.  This specifies how many times in a row the key combination
      must be pressed for the input event to cause the input event
      handler to be called.</para>
    </section>

    <section id="sgbraillebindings"><title>Braille Bindings</title>

      <para>Refreshable braille displays have buttons that the user
      can press.  The BrlTTY system <citation><xref linkend="brltty"
      endterm="brltty.abbrev"/></citation> provides a means for
      standardizing the types of input events one can generate using
      these buttons, and a script can set up braille bindings to
      handle these events.</para>

      <para>The braille bindings for a script are held in the
      <literal>brailleBindings</literal> field of a script, which is a
      a dictionary where the keys are BrlTTY commands
      (e.g., <literal>CMD_HWINLT</literal>), and the values are
      <literal>orca.input_event.InputEventHandler</literal> instances.
      The <literal>brailleBindings</literal> field is obtained by
      calling the script's <literal>getBrailleBindings</literal>
      method in the script's initializer method.</para>

      <para>An example from <literal>orca/default.py</literal> is as 
      follows:</para>

<programlisting>
def getBrailleBindings(self):
    """Defines the braille bindings for this script.

    Returns a dictionary where the keys are BrlTTY commands and the
    values are InputEventHandler instances.
    """
    brailleBindings = script.Script.getBrailleBindings(self)
    brailleBindings[braille.CMD_FWINLT]   = \
        self.inputEventHandlers["panBrailleLeftHandler"]
    brailleBindings[braille.CMD_FWINRT]   = \
        self.inputEventHandlers["panBrailleRightHandler"]
    brailleBindings[braille.CMD_LNUP]     = \
        self.inputEventHandlers["reviewAboveHandler"]
    brailleBindings[braille.CMD_LNDN]     = \
        self.inputEventHandlers["reviewBelowHandler"]
    brailleBindings[braille.CMD_FREEZE]   = \
        self.inputEventHandlers["toggleFlatReviewModeHandler"]
    brailleBindings[braille.CMD_TOP_LEFT] = \
        self.inputEventHandlers["reviewHomeHandler"]
    brailleBindings[braille.CMD_BOT_LEFT] = \
        self.inputEventHandlers["reviewBottomLeftHandler"]
    brailleBindings[braille.CMD_HOME]     = \
        self.inputEventHandlers["goBrailleHomeHandler"]

    return brailleBindings
</programlisting>

    </section>
  </chapter>

  <!--
  ************************************************************************
  *                                                                      *
  * SCRIPT HELPER UTILITIES                                              *
  *                                                                      *
  ************************************************************************
  -->

  <chapter id="sgutilities"><title>Script Utilities</title>

    <para>There are many common things a script wants to do: generate
      speech, update braille, etc.  In addition, there are many common
      things a script writer wants to do, especially getting debug
      output to determine just what the AT-SPI is sending it.  This
      chapter discusses the debug utilities of Orca as well as a
      variety of utilities to assist a script in managing speech and
      braille.</para>
    
    <section id="sgtts"><title>Speech Synthesis</title>

      <para>Orca provides two main modules for speech output:
      <literal>orca.speech</literal>
      (in <literal>orca/speech.py</literal>) and
      <literal>orca.speechgenerator</literal>
      (in <literal>orca/speechgenerator.py</literal>). The
      <literal>orca.speech</literal> module provides the main
      interface to the speech synthesis subsystem. The
      <literal>orca.speechgenerator</literal> module provides the
      <literal>orca.speechgenerator.SpeechGenerator</literal> class
      that can be used to generate the text to be spoken for various
      objects.  The expected use of the two modules is as follows: a
      script will create its own instance of
      <literal>orca.speechgenerator.SpeechGenerator</literal> and will
      use it to generate text.  The script will then pass this text to
      <literal>orca.speech</literal> to be spoken.</para>

      <section id="sgspeechpy"><title><literal>orca.speech</literal></title>
 
        <para>For the purposes of script writing, the main entry
        points of the <literal>orca.speech</literal> module are
        <literal>speak</literal>,
        <literal>speakUtterances</literal>, 
	<literal>sayAll</literal>,
	<literal>speakCharacter</literal>,
	<literal>speakKeyEvent</literal>, and
        <literal>stop</literal></para>

        <para>See the <literal>orca.speech</literal> module for more
        information.</para>

      </section>

      <section id="sgsgpy"><title><literal>orca.speechgenerator.SpeechGenerator</literal></title>

        <para>The primary goal of
        an <literal>orca.speechgenerator.SpeechGenerator</literal>
        instance, which is available as
        the <literal>speechGenerator</literal> field of a script, is
        to create text to be spoken for an accessible object.  There
        are two public entry points into a
        <literal>SpeechGenerator</literal>:</para>

        <itemizedlist>
          <listitem>
            <para><literal>getSpeech(obj, already_focused)</literal>:
            returns a list of strings to be spoken
            for the given accessible object.  The
            <literal>already_focused</literal> boolean parameter
            provides a hint to the speech generator about how much
            text to generate.  For example, if a check box that
            already has focus is to be spoken, usually the reason
            for this is that the state changed between checked and
            unchecked.  As a result, an appropriate thing to do in
            this situation is to only speak the new change in
            state (e.g., "checked").</para>              
          </listitem>
          <listitem>
            <para><literal>getSpeechContext(obj,
            stopAncestor)</literal>: returns a list of strings to be
            spoken that describe the visual context of the given
            accessible object.  This is loosely represented by the
            hierarchical relationship of the object (i.e., the "Quit"
            button in the "File" menu in the ...), and the amount of
            information can be contained by specifying an accessible
            <literal>stopAncestor</literal> above which we do not want
            to know anything about.  The primary use of this method is
            to provide the user with feedback regarding the relevant
            visual context information that changed when the locus of
            focus changes, but this method is also useful for
            assisting in "where am I" queries.</para>
          </listitem>
        </itemizedlist>
 
        <para>Custom scripts which want to override the behavior of
        the default speech generator can create their own speech
        generator.  Internally,
        the <literal>orca.speechgenerator.SpeechGenerator</literal>
        class obtains the speech for an object based upon the object's
        role.  It does so by creating and using a table
        called <literal>speechGenerators</literal>.  The keys for the
        table are <literal>pyatspi</literal> roles such
        as <literal>pyatspi.ROLE_CHECK_BOX</literal> and the values
        are a function in the script.  As such, the typical thing a
        <literal>orca.speechgenerator.SpeechGenerator</literal>
        subclass does is just override a function.  Here's a brief
        example of the meaningful components of the speech generator
        for the Pidgin application.  From the script side, the Pidgin
        script, held
        in <literal>orca/scripts/apps/pidgin/script.py</literal>,
        imports the custom Pidgin speech generator, held in
        <literal>orca/scripts/apps/pidgin/speech_generator.py</literal>,
	imports the custom speech generator and creates an instance of
	it via an overridden <literal>getSpeechGenerator</literal>
	method:</para>
<programlisting>
...
from speech_generator import SpeechGenerator
...
def getSpeechGenerator(self):
        """Returns the speech generator for this script.
        """
        return SpeechGenerator(self)
</programlisting>

        <para>The speech generator itself merely is a class declaration
        that extends the <literal>orca.speechgenerator.SpeechGenerator</literal>
        class and overrides the <literal>_getSpeechForTableCell</literal>
        method to provide customized behavior for Pidgin table cells:</para>
<programlisting>
import pyatspi

import orca.settings as settings
import orca.speechgenerator as speechgenerator

from orca.orca_i18n import _
from orca.orca_i18n import ngettext  # for ngettext support

########################################################################
#                                                                      #
# Custom SpeechGenerator                                               #
#                                                                      #
########################################################################

class SpeechGenerator(speechgenerator.SpeechGenerator):
    """Overrides _getSpeechForTableCell() so that we can provide access
    to the expanded/collapsed state and node count for the buddy list.
    """

    def __init__(self, script):
        speechgenerator.SpeechGenerator.__init__(self, script)

    def _getSpeechForTableCell(self, obj, already_focused):
        """Get the speech utterances for a single table cell

        Arguments:
        - obj: the table cell
        - already_focused: False if object just received focus

        Returns a list of utterances to be spoken for the object.
        """

        utterances = speechgenerator.SpeechGenerator._getSpeechForTableCell( \
            self, obj, already_focused)

        if not self._script.isInBuddyList(obj):
            return utterances

        # The Pidgin buddy list consists of two columns. The column which
        # is set as the expander column and which also contains the node
        # relationship is hidden.  Hidden columns are not included among
        # a table's columns.  The hidden object of interest seems to always
        # immediately precede the visible object.
        #
        expanderCell = obj.parent[obj.getIndexInParent() - 1]
        if not expanderCell:
            return utterances

        state = expanderCell.getState()
        if state.contains(pyatspi.STATE_EXPANDABLE):
            if state.contains(pyatspi.STATE_EXPANDED):
                # Translators: this represents the state of a node in a tree.
                # 'expanded' means the children are showing.
                # 'collapsed' means the children are not showing.
                #
                utterances.append(_("expanded"))
                childNodes = self._script.getChildNodes(expanderCell)
                children = len(childNodes)

                if not children \
                   or (settings.speechVerbosityLevel == \
                       settings.VERBOSITY_LEVEL_VERBOSE):
                    # Translators: this is the number of items in a layered
                    # pane or table.
                    #
                    itemString = ngettext("%d item",
                                          "%d items",
                                          children) % children
                    utterances.append(itemString)
            else:
                # Translators: this represents the state of a node in a tree.
                # 'expanded' means the children are showing.
                # 'collapsed' means the children are not showing.
                #
                utterances.append(_("collapsed"))

        self._debugGenerator("gaim._getSpeechForTableCell",
                             obj,
                             already_focused,
                             utterances)

        return utterances
</programlisting>

        <para>&note; Orca currently provides some level of support for
        verbosity via the <literal>VERBOSITY_LEVEL</literal> fields
        of the <literal>orca.settings</literal> module.  There are
        currently two verbosity levels:
        <literal>VERBOSITY_LEVEL_BRIEF</literal> and
        <literal>VERBOSITY_LEVEL_VERBOSE</literal>.  A
        <literal>orca.speechgenerator.SpeechGenerator</literal>
        subclass is expected to examine
        the <literal>speechVerbosityLevel</literal> property of
        the <literal>orca.settings</literal> module and provide the
        appropriate level of text, as shown in the above snippet
        from the Pidgin speech generator.</para>
      </section>

    </section>

    <section id="sgbrailleoutput"><title>Braille Output</title>

      <para>Like speech, Orca provides two main modules for braille:
      <literal>orca.braille</literal> (in <literal>orca/braille.py</literal> and
      <literal>orca.braillegenerator</literal> (in <literal>orca/braillegenerator.py</literal>. The
      <literal>orca.braille</literal> module provides the main
      interface to the braille display. The
      <literal>orca.braillegenerator</literal> module provides a
      <literal>BrailleGenerator</literal> class that can be used to to
      actually generate the text to be displayed for various objects.
      The expected use of the two modules is as follows: a script will
      create its own instance of a
      <literal>orca.braillegenerator.BrailleGenerator</literal> and
      will use it to braille regions.  The script will then pass these
      braille regions to the
      <literal>orca.braille</literal> module to be displayed.</para>

      <section id="sgbraillepy"><title><literal>orca.braille</literal></title> 

	<para>A good way to learn how <literal>orca.braille</literal>
        and <literal>orca.braillegenerator.BrailleGenerator</literal>
        are used is by looking at the code.
        The <literal>updateBraille</literal> method
        of <literal>orca.default.Script</literal>
        (in <literal>orca/default.py</literal>) shows the key uses:</para>
<programlisting>
def updateBraille(self, obj, extraRegion=None):
    """Updates the braille display to show the give object.

    Arguments:
    - obj: the Accessible
    - extra: extra Region to add to the end
    """

    if not obj:
        return

    braille.clear()

    line = braille.Line()
    braille.addLine(line)

    # For multiline text areas, we only show the context if we
    # are on the very first line.  Otherwise, we show only the
    # line.
    #
    try:
        text = obj.queryText()
    except NotImplementedError:
        text = None
    if text and self.isTextArea(obj):
        [lineString, startOffset, endOffset] = text.getTextAtOffset(
            text.caretOffset,
            pyatspi.TEXT_BOUNDARY_LINE_START)
        if startOffset == 0:
            line.addRegions(self.brailleGenerator.getBrailleContext(obj))
    else:
        line.addRegions(self.brailleGenerator.getBrailleContext(obj))

    result = self.brailleGenerator.getBrailleRegions(obj)
    line.addRegions(result[0])

    if extraRegion:
        line.addRegion(extraRegion)

    if extraRegion:
        braille.setFocus(extraRegion)
    else:
        braille.setFocus(result[1])

    braille.refresh(True)
</programlisting>
        <para>The key operations are:</para>

        <orderedlist numeration="arabic">
          <listitem>
            <para><literal>braille.clear()</literal>: clears the braille display</para>
          </listitem>
          <listitem>
            <para><literal>line = braille.Line()</literal>
            and <literal>braille.addLine(line)</literal>: creates a new
            empty <literal>orca.braille.Line</literal> object to which
            we can add <literal>orca.braille.Region</literal>
            instances</para>
          </listitem>
          <listitem>
            <para><literal>line.addRegions(...)</literal>: Typically,
            a script will "build up" a single logical line of text for
            the braille display.  The beginning of this line will be
            the result of a call to the
            <literal>getBrailleContext</literal> method of the
            script's <literal>brailleGenerator</literal> and the
            remainder of the line will be the result of one or more
            calls to the <literal>getBrailleRegions</literal> of the
            script's
            <literal>brailleGenerator</literal>.  Since the logical
            line will typically be longer than the number of cells on
            the braille display, the <literal>orca.braille</literal>
            module will scroll to show the
            <literal>orca.braille.Region</literal> with focus.
            Furthermore, the
            <literal>orca.braille</literal> module will also respond
            to BrlTTY input events to allow the user to use braille
            display input buttons for scrolling to review the entire
            line.</para>
          </listitem>
	  <listitem>
	    <para><literal>braille.setFocus(...)</literal>: tells the
            <literal>orca.braille</literal> module which 
	    <literal>orca.braille.Region</literal> has "focus" and should
            get the braille cursor</para>
          </listitem>
	  <listitem>
	    <para><literal>braille.refresh(...)</literal>: tells the
            <literal>orca.braille</literal> module to refresh/repaint
            the braille display based upon
            the <literal>orca.braille.Line</literal> that was built up
            above</para>
          </listitem>
        </orderedlist>

      </section>

      <section id="sgbgpy"><title><literal>orca.braillegenerator.BrailleGenerator</literal></title>

        <para>The primary goal of
        a <literal>orca.braillegenerator.BrailleGenerator</literal>
        is to create the braille text to be displayed for an
        accessible object.  There are two public entry points into a
        <literal>orca.braillegenerator.BrailleGenerator</literal>:</para>

        <itemizedlist>
          <listitem>
            <para><literal>getBrailleRegions(obj,
            groupChildren=True)</literal>: returns a list of two
            items: the first is an ordered list of braille
            <literal>Region</literal> instances that represent text to
            be displayed on the braille display, left-to-right on one
            line; and the second is an element from the first list
            that represents which <literal>Region</literal> has
            "focus" and should be represented by the braille cursor on
            the display.</para>
          </listitem>
          <listitem>
            <para><literal>getBrailleContext(obj)</literal>: returns
            an ordered list (i.e., an array) of braille
            <literal>Region</literal> instances that describe the
            visual context of the given accessible object.  This is
            loosely represented by the hierarchical relationship of
            the object (i.e., the "Quit" button in the "File" menu
            in the ...).</para>
          </listitem>
        </itemizedlist>

        <para>Custom scripts which want to override the behavior of
        the default braille generator can create their own braille
        generator.  Internally,
        the <literal>orca.braillegenerator.BrailleGenerator</literal>
        class obtains the braille for an object based upon the object's
        role.  It does so by creating and using a table
        called <literal>brailleGenerators</literal>.  The keys for the
        table are <literal>pyatspi</literal> roles such
        as <literal>pyatspi.ROLE_CHECK_BOX</literal> and the values
        are a function in the script.  As such, the typical thing a
        <literal>orca.braillegenerator.BrailleGenerator</literal>
        subclass does is just override a function.  Here's a brief
        example of the meaningful components of the speech generator
        for the Rhythmbox application.  From the script side, the Rhythmbox
        script, held
        in <literal>orca/scripts/apps/rhythmbox/script.py</literal>,
        imports the custom Rhythmbox speech generator, held in
        <literal>orca/scripts/apps/rhythmbox/braille_generator.py</literal>,
	imports the custom braille generator and creates an instance of
	it via an overridden <literal>getBrailleGenerator</literal>
	method:</para>
<programlisting>
...
from braille_generator import BrailleGenerator
...
def getBrailleGenerator(self):
        """Returns the braille generator for this script.
        """
        return BrailleGenerator(self)
</programlisting>

        <para>The braille generator itself merely is a class declaration
        that extends the <literal>orca.braillegenerator.BrailleGenerator</literal>
        class and overrides the <literal>_getSpeechForTableCell</literal>
        method to provide customized behavior for Rhythmbox table cells:</para>
<programlisting>
import orca.braillegenerator as braillegenerator

class BrailleGenerator(braillegenerator.BrailleGenerator):
    """Overrides _getBrailleRegionsForTableCell to correctly handle 
    the table cells in the Library table.
    """

    def __init__(self, script):
        braillegenerator.BrailleGenerator.__init__(self, script)

    def _getBrailleRegionsForTableCell(self, obj):
        """Get the braille for a single table cell

        Arguments:
        - obj: the table

        Returns a list where the first element is a list of Regions to 
        display and the second element is the Region which should get focus.
        """

        # Check to see if this is a table cell from the Library table.
        # If so, it'll have five children and we are interested in the
        # penultimate one. See bug #512639 for more details.
        #
        if obj.childCount == 5:
            obj = obj[3]

        return braillegenerator.BrailleGenerator.\
                    _getBrailleRegionsForTableCell(self, obj)
</programlisting>

        <para>&note; Orca currently provides some level of support for
        verbosity via the <literal>VERBOSITY_LEVEL</literal> fields
        of the <literal>settings.py</literal> module.  There are
        currently two verbosity levels:
        <literal>VERBOSITY_LEVEL_BRIEF</literal> and
        <literal>VERBOSITY_LEVEL_VERBOSE</literal>.  A
        <literal>BrailleGenerator</literal> subclass is expected to
        examine the <literal>brailleVerbosityLevel</literal> property
        of the <literal>settings.py</literal> module and provide the
        appropriate level of text:</para>

<programlisting>
if settings.brailleVerbosityLevel == settings.VERBOSITY_LEVEL_VERBOSE:
    regions.append(braille.Region(
                   " " + rolenames.getBrailleForRoleName(obj)))
</programlisting>

      </section>
    </section>

    <section id="debug"><title>Debug Utilities</title>

      <para>The <literal>orca.debug</literal> module (defined in
      <literal>orca/debug.py</literal>) of Orca provide a means
      for selectively turning on information to be sent to the
      console where Orca is running.  This information is quite
      useful in determining what is happening inside Orca as well as
      what the AT-SPI is sending to Orca.</para>

      <para>Let's begin the discussion of the debug utilities with the
      top question on any script writer's mind: "What do I name my
      script?"  As you may recall, the name of a script is based
      upon the name of the application as given to us by the AT-SPI.
      One of the easy ways to determine this is to listen for
      <literal>window:activate</literal> events that will be issued
      when an application is started.  These events can then be used
      to determine the name of the application.</para>

      <para>Fortunately, the
      <literal>focus_tracking_presenter</literal> already registers
      for <literal>window:activate</literal> events, so all you need
      to do is tell Orca to print these events out when it receives
      them.  The method for doing this involves telling the debug
      utilities what to do, and this can be done by modifying your
      <literal>~/.orca/user-settings.py</literal> or creating
      <literal>~/.orca/orca-customizations.py</literal>.  The
      <literal>~/.orca/user-settings.py</literal> file is overwritten
      each time you save your Orca preferences when running the
      Orca preferences GUI, so you might be best off creating
      <literal>~/.orca/orca-customizations.py</literal>, which is left
      untouched.</para>

      <para>The most common method for enabling debugging is to 
      change two settings in <literal>orca.debug</literal>:</para>

<programlisting>
import orca.debug
orca.debug.debugLevel = orca.debug.LEVEL_ALL
orca.debug.debugFile = open(time.strftime('/tmp/debug-%Y-%m-%d-%H:%M:%S.out'), 'w', 0) 
</programlisting>

      <para>These two lines will tell Orca to send very detailed debug
      information to a file under the <literal>/tmp</literal>
      directory.  The filename will begin
      with <literal>debug</literal> end in <literal>.out</literal>,
      and there will be a timestamp in between.  With these lines in
      place, this file be created whenever you run
      the <literal>orca</literal> command.</para>

      <para>If you run Orca and give focus to the application you are
      interested in, you a <literal>window:activate</literal> event
      will be sent to the debug file.  For example, if you
      run <literal>gcalctool</literal>, you should see output similar
      to the following:</para>

<programlisting>
vvvvv PROCESS OBJECT EVENT window:activate vvvvv
OBJECT EVENT: window:activate                          detail=(0,0)
    app.name='gcalctool' name='Calculator' role='frame' state='active enabled resizable sensitive showing visible' relations=''
</programlisting>

      <para>The string <literal>app.name='gcalctool'</literal>
      indicates the name of the application.  As such, if you wanted
      to write a custom script, you would call it
      <literal>gcalctool</literal>.</para>

      <para>&note; you can also get other information while Orca is
      running by pressing the debug keystrokes:</para>

      <itemizedlist>
        <listitem>
	  <para><literal>Orca+Control+Alt+End</literal>: dump a list
	  of all applications to the console and debug log</para>
	</listitem>
        <listitem>
	  <para><literal>Orca+Control+Alt+Home</literal>:
	  speak/braille information about the active script and
	  application with focus, and also send the information to the
	  console and debug log</para>
	</listitem>
        <listitem>
	  <para><literal>Orca+Control+Alt+PageUp</literal>: dump the
	  ancestors of the <literal>locusOfFocus</literal> to the
	  console and debug log</para>
	</listitem>
        <listitem>
	  <para><literal>Orca+Control+Alt+PageDown</literal>: dump the
	    entire widget hierarchy of the application with focus to
	    the console and debug log</para>
	</listitem>
      </itemizedlist>

      <para>The debug module also includes a number of other methods,
      each of which is described in more detail in
      <literal>orca/debug.py</literal>.  Note that each method
      includes a debug level threshold.
      The <literal>orca/debug.py</literal> module has a description of
      various level settings and what to expect for output.  A few of
      the interesting methods are as follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal>orca.debug.printException(level)</literal>:
          if an exception is caught, this can be used to print out
          detail about it</para>
        </listitem>
        <listitem>
          <para><literal>orca.debug.printStack(level)</literal>:
          prints the current stack; useful for determining when and
          why a code path is being executed</para>
        </listitem>
        <listitem>
          <para><literal>orca.debug.println(level, text)</literal>:
          prints the given text; useful for general debug
          output</para>
        </listitem>
        <listitem>
          <para><literal>orca.debug.getAccessibleDetails(obj)</literal>:
          obtains a string describing the name, description, state,
          roles, etc., for the given <literal>pyatspi.Accessible</literal>.
          This can be sent to <literal>orca.debug.println</literal>,
          for example.</para>
        </listitem>
      </itemizedlist>

      <para>&note; One debug level of interest is
      <literal>debug.LEVEL_FINE</literal>.  This level will tell you
      when a script is activated, and can be useful to determine if
      Orca is actually finding your script.  For example, when the
      script for the <literal>gnome-terminal</literal> is activated by
      the <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>,
      you will see the following output in the debug output:</para>

<programlisting>
ACTIVE SCRIPT: gnome-terminal (module=orca.scripts.apps.gnome-terminal) (reason=window:activate event)
</programlisting>

      <para>Notice that the class of the script instance is included.
      If you determine that this class is not what you expect when
      you are developing your custom script, then something went
      wrong when trying to find or load your custom script.  This
      can often happen because Python performs a lot of late binding
      and compilation, thus errors are often not encountered until a
      specific code path is executed at run time.  You can tell the
      <literal>orca.focus_tracking_presenter.FocusTrackingPresenter</literal>
      to give you more information about any possible failures or
      exceptions it handles in this area by setting the debug level
      to <literal>debug.LEVEL_FINEST</literal>.</para>

    </section>

  </chapter>
