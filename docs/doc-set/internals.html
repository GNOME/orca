<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Orca Technical Reference</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id2488862"></a>Orca Technical Reference</h1></div><div><div class="legalnotice"><a name="id2489718"></a><p>Copyright 2005-2009, Sun Microsystems, Inc.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#archforward">Foreword</a></span></dt><dt><span class="chapter"><a href="#prereq">1. Prerequisites</a></span></dt><dd><dl><dt><span class="section"><a href="#prereqgnome">GNOME</a></span></dt><dt><span class="section"><a href="#prereqpython">Python v2.4 or better</a></span></dt><dt><span class="section"><a href="#prereqbrltty">BrlTTY v3.7.2 or better</a></span></dt><dt><span class="section"><a href="#prereqkeyboardnav">Keyboard Navigation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#archdesktop">Desktop and AT-SPI</a></span></dt><dt><span class="section"><a href="#archorca">Orca Module</a></span></dt><dd><dl><dt><span class="section"><a href="#archsettings">settings</a></span></dt></dl></dd><dt><span class="section"><a href="#script">Orca Scripts</a></span></dt><dt><span class="section"><a href="#archsystemservices">System Services</a></span></dt><dd><dl><dt><span class="section"><a href="#archspeech">speech</a></span></dt><dt><span class="section"><a href="#archbraille">braille</a></span></dt><dt><span class="section"><a href="#archmag">mag</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#scriptguide">3. Introduction to Scripting</a></span></dt><dd><dl><dt><span class="section"><a href="#sgcontract">Script Contract</a></span></dt><dt><span class="section"><a href="#sglifecycle">Script Life Cycle</a></span></dt></dl></dd><dt><span class="chapter"><a href="#customization">4. Customized Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="#sgeventlisteners">Defining Event Listeners</a></span></dt><dt><span class="section"><a href="#sginputeventhandlers">Input Event Handlers</a></span></dt><dt><span class="section"><a href="#sgkeybindings">Defining Keyboard Bindings</a></span></dt><dt><span class="section"><a href="#sgbraillebindings">Defining Braille Bindings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#sgutilities">5. Script Utilities</a></span></dt><dd><dl><dt><span class="section"><a href="#debug">Debug Utilities</a></span></dt><dt><span class="section"><a href="#sgtts">Speech Synthesis</a></span></dt><dd><dl><dt><span class="section"><a href="#sgspeechpy"><code class="literal">speech.py</code></a></span></dt><dt><span class="section"><a href="#sgsgpy"><code class="literal">speechgenerator.py</code></a></span></dt></dl></dd><dt><span class="section"><a href="#sgbrailleoutput">Braille Output</a></span></dt><dd><dl><dt><span class="section"><a href="#sgbraillepy"><code class="literal">braille.py</code></a></span></dt><dt><span class="section"><a href="#sgbgpy"><code class="literal">braillegenerator.py</code></a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#i18n">6. Internationalization (I18N) Support</a></span></dt><dt><span class="bibliography"><a href="#archbibliography">Bibliography</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>2.1. <a href="#id2489678">High Level Orca Architecture. The main components of Orca
      are as follows: desktop applications that support the AT-SPI,
      the AT-SPI registry and infrastructure, Orca itself, Orca
      Scripts, and system services.  The key communication between the
      components is depicted.</a></dt><dt>4.1. <a href="#id2493370">Orca Script Diagram</a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="archforward"></a>Foreword</h2></div></div></div><p>Orca is a free, open source, flexible, and extensible screen
reader that provides access to the graphical desktop via
user-customizable combinations of speech, braille, and/or
magnification.  Under development by the Sun Microsystems, Inc.,
Accessibility Program Office since 2004, Orca has been created with
early input from and continued engagement with its end users.</p><p>Orca works with applications and toolkits that support the
assistive technology service provider interface (AT-SPI), which is the
primary assistive technology infrastructure for the Solaris and Linux
operating environments.  Applications and toolkits supporting the
AT-SPI include the GNOME GTK+ toolkit, the Java platform's Swing
toolkit, OpenOffice, and Mozilla.  AT-SPI support for WebKit and the
KDE Qt toolkit is currently being pursued.</p><p>See also http://live.gnome.org/Orca for detailed English and
Spanish information on Orca, including how to run Orca, how to
communicate with the Orca user community, and where to log bugs and
feature requests.</p><p>This book covers the overall architecture of Orca, including
    a portion on writing custom scripts. The bulk of the end user
    information and user experience design can be found on the 
    <a href="http://live.gnome.org/Orca" target="_top">Orca WIKI</a>.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="prereq"></a>Chapter 1. Prerequisites</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#prereqgnome">GNOME</a></span></dt><dt><span class="section"><a href="#prereqpython">Python v2.4 or better</a></span></dt><dt><span class="section"><a href="#prereqbrltty">BrlTTY v3.7.2 or better</a></span></dt><dt><span class="section"><a href="#prereqkeyboardnav">Keyboard Navigation</a></span></dt></dl></div><p>Orca is a screen reader that needs to be able to interact
    with speech synthesis, braille, and screen magnification services,
    but it need not be the provider of such services. To help narrow
    the scope of the Orca development activity, Orca uses existing
    software where available.  As such, Orca has the following
    dependencies.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="prereqgnome"></a>GNOME</h2></div></div></div><p>Orca is part of the GNOME project and ships with each
      release of GNOME.  Because Orca uses a number of GNOME
      components, such as AT-SPI, ATK, GAIL, gnome-speech, gnome-mag,
      and GTK+, Orca is only supported on the release of GNOME with
      which it was released.  For example, Orca v2.22.0 was released
      with GNOME 2.22.0 and is only supported on GNOME 2.22.0.  To
      determine the version of Orca you are using, run the following
      command:
</p><pre class="programlisting">
orca --version
</pre><p>
      To determine the version of GNOME you are using, run the
      following command:
</p><pre class="programlisting">
gnome-about --version
</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="prereqpython"></a>Python v2.4 or better</h2></div></div></div><p>Orca is written in the Python programming language and
      depends upon features found in Python versions 2.4 and
      greater. To determine the version of Python you are using, run
      the following command:
</p><pre class="programlisting">
python -V
</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="prereqbrltty"></a>BrlTTY v3.7.2 or better</h2></div></div></div><p>BrlTTY [<span class="citation"><a href="#brltty">BRLTTY</a></span>] provides access to a
      variety of Braille displays, and consists of a library and a
      daemon to provide programmatic interaction with the
      display.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="prereqkeyboardnav"></a>Keyboard Navigation</h2></div></div></div><p>As much as possible, Orca relies upon the keyboard
      navigation methods built in to the native platform.  For
      example, it is expected that the native platform will provide
      access via traditional methods such as the "tab" key, keyboard
      mnemonics, and keyboard accelerators.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter 2. Architecture</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#archdesktop">Desktop and AT-SPI</a></span></dt><dt><span class="section"><a href="#archorca">Orca Module</a></span></dt><dd><dl><dt><span class="section"><a href="#archsettings">settings</a></span></dt></dl></dd><dt><span class="section"><a href="#script">Orca Scripts</a></span></dt><dt><span class="section"><a href="#archsystemservices">System Services</a></span></dt><dd><dl><dt><span class="section"><a href="#archspeech">speech</a></span></dt><dt><span class="section"><a href="#archbraille">braille</a></span></dt><dt><span class="section"><a href="#archmag">mag</a></span></dt></dl></dd></dl></div><p>The Orca architecture has been driven primarily by the Orca
    User Experience Design.  There are two primary operating modes
    of Orca: a focus tracking mode and a flat review mode.</p><p>The focus tracking mode is the preferred mode of operation.
    It generally relies upon applications to provide reasonable
    keyboard navigation techniques to allow the user to operate the
    application without requiring the mouse.  As the user uses
    traditional keyboard navigation techniques to move from component
    to component in the application (e.g., pressing the Tab key to
    move from pushbutton to text area to toggle button, etc.), Orca
    will present this to the user via braille, speech, magnification,
    or a combination thereof.  In the cases where more complex
    navigation is needed, such as structural navigation of complex
    text documents, Orca also provides a facility to define keyboard
    and braille input events that it can intercept and handle
    appropriately.</p><p>The flat review mode provides the user with the ability to
    spatially navigate a window, giving them the ability to explore as
    well as discover and interact with components in the window. This
    mode is not a preferred mode, but is instead intended to allow a
    user to interact with ill-behaved applications.  Orca provides a
    default set of keybindings for flat review, and these keybindings
    can be easily redefined by the user.</p><p>The focus tracking mode of Orca is handled by "scripts,"
    which are Python modules that can provide a custom interpretation
    of an application's interaction model.  It is not intended that
    there will be a unique script for every application.  Instead, it
    is expected that there will be a general purpose "default" script
    that covers a large number of applications.  In the event that
    more compelling or custom behavior is desired for an application,
    however, one can use a custom script for the application.
    Furthermore, scripts can subclass other scripts, allowing them to
    be quite simple. In practice, all the custom scripts extend the
    "default" script.</p><p>As illustrated in the high level Orca architecture diagram,
    the main components of Orca are as follows: desktop applications
    that support the AT-SPI, the AT-SPI registry and infrastructure,
    Orca itself, Orca Scripts, and system services (e.g., speech,
    braille, magnification).</p><div class="figure"><a name="id2489678"></a><p class="title"><b>Figure 2.1. High Level Orca Architecture. The main components of Orca
      are as follows: desktop applications that support the AT-SPI,
      the AT-SPI registry and infrastructure, Orca itself, Orca
      Scripts, and system services.  The key communication between the
      components is depicted.</b></p><div class="mediaobject"><img src="architecture.png" alt="High Level Orca Architecture"></div></div><p>The following sections describe the architecture in more
    detail.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="archdesktop"></a>Desktop and AT-SPI</h2></div></div></div><p>Orca's sole view of any application on the desktop is via
      the AT-SPI [<span class="citation"><a href="#at-spi">AT-SPI</a></span>].  The AT-SPI is an
      IDL/CORBA/Bonobo-based
      technology [<span class="citation"><a href="#bonobo">Bonobo</a></span>] that provides a common
      interface for the desktop and its applications to expose their
      GUI component hierarchy to assistive technologies such as Orca.
      <span class="emphasis"><em>NOTE:</em></span> the AT-SPI infrastructure is being migrated to D-Bus for
      GNOME 3.0.  This migration should have little impact on the
      architecture or code of Orca.  In other words, do you worry
      'bout a thing.</p><p>AT-SPI support is provided by toolkits such as GNOME's
      GTK+ toolkit (via GAIL [<span class="citation"><a href="#gail">GAIL</a></span>]), the Java platform (via the
      Java access bridge), and the custom toolkits used by
      applications such as Mozilla and Open Office.  Future support
      includes the Qt toolkit of KDE.</p><p>Assistive Technologies interact with the AT-SPI via two
      primary means: the AT-SPI registry and accessible objects.  The
      AT-SPI registry permits assistive technologies to discover
      existing applications on the desktop and to register for event
      notification for AT-SPI events (e.g., window creation, focus
      changes, object state changes, etc.) and device events (e.g.,
      keyboard input events).  Accessible objects provide the
      assistive technology with information about the application, and
      tend to mirror the actual GUI component hierarchy.  Accessible
      objects can be obtained in three ways: </p><div class="orderedlist"><ol type="1"><li><p>From the AT-SPI registry via queries on the desktop</p></li><li><p>From an AT-SPI event</p></li><li><p>From another Accessible via parent/child relationships
            and other relationships such as "label for" and 
	    "labeled by".</p></li></ol></div><p>Orca's interaction with the AT-SPI is managed through the
      <code class="literal">pyatspi.py</code> module that is part of AT-SPI.  The
      <code class="literal">pyatspi.py</code> module communicates directly with
      the AT-SPI number of classes that help with AT-SPI interaction.
      The best ways to learn AT-SPI are as follows:

      </p><div class="orderedlist"><ol type="1"><li><p>Read the AT-SPI interface documentation.</p></li><li><p>Run the <code class="literal">accerciser</code> application to
          examine the accessibility information of desktop
          applications.  This includes analyzing the accessible
          hierarchy as well as watching events that are issued as
          you interact with desktop applcations.</p></li><li><p>Enable the debug mode of Orca as described on the
          <a href="http://live.gnome.org/Orca/Debugging" target="_top">Orca
          WIKI</a>.  Run Orca and interact with an
          application. Then, quit Orca and analyze the debug
          log.</p></li></ol></div><p>
      </p><p>As illustrated in the high level Orca architecture
      diagram, the <code class="literal">pyatspi</code> module has been used to
      register event and device listeners with the AT-SPI registry.
      Each exemplary desktop application (Firefox, Evolution, Pidgin,
      and OpenOffice) emits AT-SPI events to the AT-SPI registry which
      then delivers them to the <code class="literal">pyatspi</code> module.
      The <code class="literal">pyatspi</code> module then calls all appropriate
      listeners for the events it receives from the AT-SPI
      registry.</p><p>In this case, the <code class="literal">orca</code> module receives
      keyboard events, which it interprets and also sends on to the
      <code class="literal">focus_tracking_presenter</code> module (not depicted
      in the illustration).  Of more
      interest, however, is that the
      <code class="literal">focus_tracking_presenter</code> module receives
      AT-SPI events which it then passes on the script for the
      application associated with the event.  If there is no script,
      the <code class="literal">focus_tracking_presenter</code> will create an
      instance of the default script.  See the <a href="#scriptguide" title="Chapter 3. Introduction to Scripting">Orca Script Writing Guide</a> for
      more information.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> Because processing AT-SPI object events can be
      time consuming, and because the notification of AT-SPI object
      events is relatively "bursty," the
      <code class="literal">focus_tracking_presenter</code> maintains a queue of
      AT-SPI object and input device events. It adds the events to
      this queue when it receives them and processes the events on the
      GLib idle handling thread.  This permits Orca to survive a
      relatively long burst of events and also allows it to handle the
      events on a thread that is compatible with GLib.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="archorca"></a>Orca Module</h2></div></div></div><p>The <code class="literal">orca</code> module is the "main entry
      point" of Orca.  It initializes the components that Orca uses
      (pyatspi, speech, braille, mag) and loads the user's settings.
      It also is the first to receive all keyboard and braille input
      events and delves them out to other Orca components
      appropriately.</p><p>The <code class="literal">orca</code> module maintains the current
      known "locus of focus" in the <code class="literal">locusOfFocus</code>
      field of the <code class="literal">orca_state</code> module.  The
      <code class="literal">orca_state.locusOfFocus</code> field is intended to
      represent the current object that the user is working with.  In
      simple terms, it is the object that is highlighted or has the
      dotted line drawn around it.  Be advised that the notion of
      "focus" differs from toolkit to toolkit.  For example, the
      object with toolkit focus may actually be the parent of the
      object that is highlighted.  As such,
      the <code class="literal">orca_status.locusOfFocus</code> field is an an
      attempt to neutralize these differences across toolkits: the
      locus of focus is the individual object that is highlighted, has
      the caret, etc.</p><p>Orca scripts
      set <code class="literal">orca_state.locusOfFocus</code> to inform Orca
      when the locus of focus has changed.  In addition, in the event
      that there was a visual appearance change to the object that has
      the locus of focus, the <code class="literal">orca</code> module provides
      a <code class="literal">visualAppearanceChanged</code> that scripts can
      use to inform Orca of this event.</p><p><span class="emphasis"><em>NOTE:</em></span> The <code class="literal">orca_state.locusOfFocus</code>
      field is intended to be set only via the
      <code class="literal">setLocusOfFocus</code> method of the
      <code class="literal">orca</code> module. Because the
      <code class="literal">orca.setLocusOfFocus</code> method performs bookkeeping
      and other tasks, the
      <code class="literal">orca_state.locusOfFocus</code> field should never be
      set directly.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="archsettings"></a>settings</h3></div></div></div><p>The <code class="literal">settings</code> module (not depicted in
        the high level Orca architecture diagram) holds preferences
        set by the user during configuration.  These settings include
        the following: use of speech, braille, and/or magnification,
        voice styles, key echo, text echo, etc.</p><p>Any Orca module can check the value of a setting by
        examining the field directly in the
        <code class="literal">settings</code> module.  In addition, the
        <code class="literal">orca</code> module will import the
        <code class="literal">user-settings</code> module from the
        <code class="literal">~/.orca directory</code>, if it exists.
        The <code class="literal">user-settings</code> module is
	created as part of the configuration process that is run the
	first time Orca is used or when the user presses 
	<code class="literal">Insert+Space</code> to invoke the configuration
	GUI.</p><p>The <code class="literal">user-settings</code> module is a Python
        script, allowing it to contain functions, class definitions,
        etc.  The primary job of the
        <code class="literal">user-settings</code>, however, is to directly set
        the values of fields in the <code class="literal">settings</code>
        module.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> the <code class="literal">init</code> method of the
        <code class="literal">orca</code> module obtains settings.  As a
        result, the <code class="literal">user-settings</code> module is
        imported very early in the Orca life cycle.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="script"></a>Orca Scripts</h2></div></div></div><p>The <code class="literal">orca</code> module creates a single
      instance of a <code class="literal">FocusTrackingPresenter</code> (defined
      in the
      <code class="literal">focus_tracking_presenter</code> module), which manages
      all the scripts for Orca.</p><p>Details on the <code class="literal">FocusTrackingPresenter</code>
      and Orca scripts can be found in the <a href="#scriptguide" title="Chapter 3. Introduction to Scripting">Orca Script Writing Guide</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="archsystemservices"></a>System Services</h2></div></div></div><p> Orca relies on existing system services to provide
      support for speech synthesis, braille, and screen magnification.
      To interact with these services, Orca provides the modules
      described in the following sections.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="archspeech"></a>speech</h3></div></div></div><p>All speaking operations should be done by calling
        methods in the <code class="literal">speech</code> module.
        The <code class="literal">speech</code> module provides Orca's Python
        interface to system speech services.  Each speech service is
        generated by a "speech server factory."  There are currently
        three such factories: one for
        [<span class="citation"><a href="#gnome-speech">gnome-speech</a></span>] (see the
        <code class="literal">gnomespeechfactory</code> module), one for
        [<span class="citation"><a href="#emacspeak">Emacspeak</a></span>] (see the
        <code class="literal">espeechfactory</code> module), and one for
        SpeechDispatcher (see
        the <code class="literal">speechdispatcherfactory</code> module).
        Currently, the only officially supported factory is the one
        provided by the <code class="literal">gnomespeechfactory</code>
        module.</p><p>Each speech factory offers up a list of
        <code class="literal">SpeechServer</code>s, where each
        <code class="literal">SpeechServer</code> is typically an interface to
        a particular speech engine.  For example, the
        <code class="literal">espeechfactory</code> will offer up a
        <code class="literal">SpeechServer</code> that talks to the Fonix
        DECtalk engine and a <code class="literal">SpeechServer</code> that
        talks to the IBMTTS engine.  Likewise, the
        <code class="literal">gnomespeechfactory</code> will offer up a
        <code class="literal">SpeechServer</code> that uses the
        <code class="literal">gnome-speech</code> interface to talk to the
        eSpeak synthesis engine, a separate
        <code class="literal">SpeechServer</code> that also uses the
        <code class="literal">gnome-speech</code> interface to talk to the Fonix
        DECtalk engine, and so on.</p><p>Each <code class="literal">SpeechServer</code> instance provides a
        set of methods for actually speaking. Many of the methods
        accepts an <code class="literal">ACSS</code> instance, which represents
        an aural cascading style sheet ([<span class="citation"><a href="#acss">ACSS</a></span>]) that defines the voice and
        voice parameter settings to use.</p><p>As part of the <code class="literal">orca-setup</code> process,
        the user selects a particular speech factory,
        <code class="literal">SpeechServer</code>, and voice to use as their
        default voice.  When Orca starts, the
        <code class="literal">speech</code> module looks for these settings
        and connects to the appropriate speech factory and
        <code class="literal">SpeechServer</code>.  In the event the a
        connection cannot be made, the <code class="literal">speech</code>
        module attempts to find a working synthesis engine to use by
        examining its list of speech factories.  The
        <code class="literal">speech</code> module then provides simple methods
        that delegate to the <code class="literal">SpeechServer</code> instance.
        Although this model allows scripts to use their own
        <code class="literal">SpeechServer</code> instances if they wish,
        scripts typically just rely upon the user's default
        preferences.</p><p><span class="emphasis"><em>NOTE:</em></span> Each Orca script has a
        single <code class="literal">speechgenerator.SpeechGenerator</code>
        instance to help generate text to be sent to
        the <code class="literal">speech</code> module.  More information on
        speech generators can be found in the
        <a href="#scriptguide" title="Chapter 3. Introduction to Scripting">Orca Script Writing Guide</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="archbraille"></a>braille</h3></div></div></div><p> The <code class="literal">braille</code> module provides Orca's
        Python interface to the system's BrlTTY
        [<span class="citation"><a href="#brltty">BRLTTY</a></span>] daemon.  The BrlTTY
        daemon, in turn, provides the interface to braille devices
        for both displaying braille and receiving input from the
        user.</p><p><span class="emphasis"><em>NOTE:</em></span> As with speech, each Orca script has a
        single <code class="literal">braillegenerator.BrailleGenerator</code>
        instance to help generate text to be sent to
        the <code class="literal">braille</code> module.  More information on
        braille generators can be found in the
        <a href="#scriptguide" title="Chapter 3. Introduction to Scripting">Orca Script Writing Guide</a>.</p><p><span class="emphasis"><em>TODO:</em></span> flesh this section out more.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="archmag"></a>mag</h3></div></div></div><p> The <code class="literal">mag</code> module
        provides Orca's Python interface to the system's gnome-mag
        [<span class="citation"><a href="#gnome-mag">gnome-mag</a></span>] CORBA service(s).  The
        magnification component provides methods that permit Orca
        discover screen magnification services and set their desktop
        region of interest.  The script is responsible for
        calling <code class="literal">mag.magnifyAccessible</code> with the
        appropriate parameters to set the magnifier's region of
        interest.</p><p><span class="emphasis"><em>TODO:</em></span> flesh this section out more.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="scriptguide"></a>Chapter 3. Introduction to Scripting</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sgcontract">Script Contract</a></span></dt><dt><span class="section"><a href="#sglifecycle">Script Life Cycle</a></span></dt></dl></div><p>In this section, you will learn more about the Orca
      architecture as well as how to create your own custom scripts
      for Orca.</p><p>The goal of scripting is to provide Orca with the capability
      of providing a natural feeling and compelling user experience
      for the various user interaction models of different desktop
      applications.</p><p>The Orca scripting approach allows scripts to extend and/or
      override the behavior of other scripts, thus simplifying the job
      of a script writer.  To further facilitate script writing, Orca
      provides a "default" script that provides a reasonable default
      behavior for Orca.  This will not only serve as the "fallback
      script" for Orca, but will also typically serve as the "jumping
      off" point for writing custom scripts.  Furthermore, keep in
      mind that the "default" script is intended to cover a large
      variety of applications.  As such, you may find that it is
      not necessary to write a custom script.</p><p>The primary operating mode of Orca is "focus tracking
      mode," where Orca keeps track of the most relevant user
      interface object that has keyboard focus.  When Orca detects
      changes to this object, which Orca refers to as the "locus of
      focus," Orca will present relevant information to the user.</p><p>As such, the primary goal of a script is to assist Orca in
      tracking of the locus of focus as well as presenting information
      about the locus of focus.  A script does this by registering for
      one or more AT-SPI events and then reacting appropriately when
      it receives those events.  A script can also intercept and
      interpret keystrokes and braille input events, allowing it to
      further extend the behavior of Orca.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sgcontract"></a>Script Contract</h2></div></div></div><p>The contract for a script is documented in detail in the
        pydoc of the <code class="literal">Script</code> class in the
        <code class="literal">script.py</code> module.  The
        <code class="literal">Script</code> subclass defined in the
        <code class="literal">default.py</code> module provides the default
        behavior for Orca when it encounters applications and toolkits
        that behave like the GTK toolkit.  It is expected that new
        scripts will typically extend the <code class="literal">Script</code>
        subclass of the <code class="literal">default.py</code> module rather
        than directly extending the <code class="literal">Script</code> class
        defined in the <code class="literal">script.py</code> module.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sglifecycle"></a>Script Life Cycle</h2></div></div></div><p>BIRTH: Orca's <code class="literal">focus_tracking_presenter</code>
        module is the sole maintainer of scripts. Whenever it receives
        an event from the AT-SPI Registry, the
        <code class="literal">focus_tracking_presenter</code> will determine the
        application associated with that event and create a new script
        for that application if on has not yet been created.  Only one
        script instance per application instance is allowed by the
        <code class="literal">focus_tracking_presenter</code>.</p><p>The script creation process consists of the following
        steps:</p><div class="itemizedlist"><ul type="disc"><li><p>The <code class="literal">focus_tracking_presenter</code> will
            attempt to perform a Python <code class="literal">import</code>
            using the application name as the name of an Orca module.
            For example, for the <code class="literal">gnome-terminal</code>
            application, the
            <code class="literal">focus_tracking_presenter</code> will look for
            the <code class="literal">gnome-terminal.py</code> in the
            <code class="literal">orca.scripts</code> package (see the script
            naming discussion in the <a href="#debug" title="Debug Utilities">debug
            utilities section</a> to determine what to name your
            script).  If it cannot find such a module in the Python
            search path, the
            <code class="literal">focus_tracking_presenter</code> will then
            check in the <code class="literal">orca</code> package for a module
            matching the name of the toolkit used by the application.
            Failing that, Orca will create an instance of the
            <code class="literal">Script</code> class defined in the
            <code class="literal">default.py</code> module.</p><p><span class="emphasis"><em>NOTE:</em></span> the <code class="literal">focus_tracking_presenter</code>
            also maintains a table to map application names to script
            names.  This is useful in many cases, such as if the
            application name changes over time or the application
            contains characters that are awkward in file system names.
            To extend or override this table, one can call the
            <code class="literal">setScriptMapping</code> method of the
            <code class="literal">settings</code> module.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> it is possible to tell Orca to bypass all
            custom script creation by setting
            <code class="literal">orca.settings.enableCustomScripts=False</code>
            in your <code class="literal">~/.orca/user-settings.py</code>
            module.  This can be useful for debugging purposes.</p></li><li><p>Each script module is expected to provide a
            <code class="literal">Script</code> class that ultimately extends
            the <code class="literal">orca.Script</code> class defined in the
            <code class="literal">script.py</code> module.  The constructor
            takes the accessible application object as an
            argument.</p><p>The constructor for the <code class="literal">Script</code>
            instance is expected to define any keystrokes, braille
            buttons, and AT-SPI event listeners it is interested in
            (see the <a href="#customization" title="Chapter 4. Customized Behavior">Customized
            Behavior</a> section for how to do this).</p></li><li><p>Once it has created a script, the
            <code class="literal">focus_tracking_presenter</code> will register
            event listeners for all AT-SPI events associated with
            script (i.e., the script should not register these events
            itself).  When the
            <code class="literal">focus_tracking_presenter</code> receives the
            events, it will pass the event to the script associated
            with the event, regardless if the application associated
            with the script has focus or not.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> the
            <code class="literal">focus_tracking_presenter</code> registers its
            own <code class="literal">processObjectEvent</code> method as the
            AT-SPI event listener.  This method finds (and creates if
            necessary) the script associated with the event and passes
            the event onto the required
            <code class="literal">processObjectEvent</code> method of the script
            for processing.  Each <code class="literal">Event</code> (see the
            <code class="literal">atspi</code> module) has the following
            fields:</p><div class="itemizedlist"><ul type="circle"><li><p><code class="literal">source</code>: an
                <code class="literal">Accessible</code> (see the
                <code class="literal">atspi</code> module) instance representing
                the object associated with the event</p></li><li><p><code class="literal">type</code>: a string describing the
                event (e.g.,
                <code class="literal">window:activated</code>)</p></li><li><p><code class="literal">detail1</code> and
                <code class="literal">detail2</code>: integer details for the
                event (see the AT-SPI documentation)</p></li><li><p><code class="literal">any_data</code>: something associated
                with the event (see the AT-SPI documentation)</p></li></ul></div></li><li><p>The <code class="literal">focus_tracking_presenter</code> also
            keeps track of the active script (as determined by the
            script associated with the currently active window) and
            will pass all keyboard and braille input events to the
            active script.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> the
            <code class="literal">focus_tracking_presenter</code> implements the
            <code class="literal">processKeyboardEvent</code> and
            <code class="literal">processBrailleEvent</code> methods which are
            called by the main <code class="literal">orca</code> module whenever
            it receives a keystroke or braille input event.  The
            <code class="literal">focus_tracking_presenter</code> will pass
            these events onto the
            <code class="literal">processKeyboardEvent</code> and
            <code class="literal">processBrailleEvent</code> methods of the
            active script.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> Because processing AT-SPI object events can
            be time consuming, and because the notification of AT-SPI
            object events is relatively "bursty," the
            <code class="literal">focus_tracking_presenter</code> maintains a
            queue of AT-SPI object and input device events. It adds
            the events to this queue when it receives them and
            processes the events on the GLib idle handling thread.
            This permits Orca to survive a relatively long burst of
            events and also allows it to handle the events on a thread
            that is compatible with GLib.</p></li></ul></div><p>LIFE: Whenever a script receives an event, the script can do
        whatever it wants.  Its primary task, however, is to assist
        Orca in keeping track of the locus of focus.  When a script
        detects a change in the locus of focus, it should call
        <code class="literal">orca.setLocusOfFocus</code> with the
        <code class="literal">Accessible</code> object instance that is the new
        locus of focus.  Among other things, this results in the
	<code class="literal">orca_state.locusOfFocus</code> field being updated.</p><p><span class="emphasis"><em>NOTE:</em></span> The <code class="literal">orca_state.locusOfFocus</code>
        field is intended to be set only via the
        <code class="literal">setLocusOfFocus</code> method of the
        <code class="literal">orca</code> module. Because the
        <code class="literal">setLocusOfFocus</code> method performs bookkeeping
        and other tasks, the
        <code class="literal">orca_state.locusOfFocus</code> field should never
        be set directly.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> The <code class="literal">orca</code> module has logic to
        detect if the locus of focus really changed and will propagate
        the change on as appropriate.  The
        <code class="literal">orca.setLocusOfFocus</code> method first sends the
        change to the <code class="literal">locusOfFocusChanged</code> method of
        the <code class="literal">focus_tracking_presenter</code>, which then
        passes the change onto the required
        <code class="literal">locusOfFocusChanged</code> method of the active
        script. The <code class="literal">locusOfFocusChanged</code> method is
        the primary place where a script will present information to
        the user.</p><p>In many cases, the locus of focus doesn't change, but some
        property of the current locus of focus changes.  For example,
        a checkbox is checked or unchecked, yet remains as the locus
        of focus.  In these cases, a script should also keep Orca
        informed by calling
        <code class="literal">orca.visualAppearanceChanged</code>.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> Like the <code class="literal">locusOfFocusChanged</code>
        method, the <code class="literal">visualAppearanceChanged</code> method
        of the <code class="literal">orca</code> module will first call the
        <code class="literal">visualAppearanceChanged</code> method of the
        <code class="literal">focus_tracking_presenter</code>, which will then
        call the required <code class="literal">visualAppearanceChanged</code>
        of the active script.  The
        <code class="literal">visualAppearanceChanged</code> is the primary
        place where a script will present such information to the
        user.</p><p>DEATH: Whenever the
        <code class="literal">focus_tracking_presenter</code> detects that an
        application has gone away (by determining that the application
        has been removed from the desktop), it will delete the script
        for that application and unregister any event listeners
        associated with that script.</p><p><span class="emphasis"><em>IMPLEMENTATION DETAIL:</em></span> the <code class="literal">focus_tracking_presenter</code>
        determines an application has gone away by detecting a 
        <code class="literal">object:children-changed:remove</code> event on
        the desktop.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="customization"></a>Chapter 4. Customized Behavior</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sgeventlisteners">Defining Event Listeners</a></span></dt><dt><span class="section"><a href="#sginputeventhandlers">Input Event Handlers</a></span></dt><dt><span class="section"><a href="#sgkeybindings">Defining Keyboard Bindings</a></span></dt><dt><span class="section"><a href="#sgbraillebindings">Defining Braille Bindings</a></span></dt></dl></div><p><span class="emphasis"><em>NOTE:</em></span> THIS WILL CHANGE POST V1.0.  In particular, the
      method for setting up event handlers and keyboard/braille
      bindings will be changed so as to allow for easier customization
      of these bindings.  As such, the information in this chapter is
      here only for historical purposes.</p><p>The customized behavior of a script is set up in its
      constructor.  In its constructor, each script is expected to
      extend/override several fields as illustrated in the following
      diagram and describe below:</p><div class="figure"><a name="id2493370"></a><p class="title"><b>Figure 4.1. Orca Script Diagram</b></p><div class="mediaobject"><img src="script.jpg" alt="Orca Script Diagram"></div></div><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">listeners</code>: a dictionary where the
          keys are strings that match AT-SPI event types (e.g.,
          <code class="literal">focus:</code>,
          <code class="literal">object:text-caret-moved</code>, etc.), and the
          values are functions to handle the event.  Each function
          is passed an <code class="literal">Event</code> instance (see the
          <code class="literal">atspi.py</code> module) as its sole
          parameter and no return value is expected.</p></li><li><p><code class="literal">keybindings</code>: an instance of 
          <code class="literal">keybindings.KeyBindings</code> (see
          the <code class="literal">keybindings.py</code> module) that defines
          the keystrokes the script is interested in.</p></li><li><p><code class="literal">braillebindings</code>: a dictionary where
          the keys are BrlTTY commands (e.g., <code class="literal">CMD_HWINLT</code>,
          defined in <code class="literal">braille.py</code>), and the values are
          <code class="literal">InputEventHandler</code> instances.</p></li></ul></div><p>The constructor for the <code class="literal">Script</code> class,
      which all scripts should ultimately extend (most will extend the
      <code class="literal">Script</code> subclass of the <code class="literal">default.py</code>
      module, which in turn extends
      <code class="literal">Script</code> class of the <code class="literal">script.py</code>
      module), sets up empty values for each of
      these fields.  As such, a subclass merely needs to
      extend/override these fields.  Each of these fields is described
      in more detail in the following sections.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sgeventlisteners"></a>Defining Event Listeners</h2></div></div></div><p>As described above, the <code class="literal">listeners</code> field
        is a dictionary where the keys are strings that match AT-SPI
        event types (e.g., <code class="literal">focus:</code>,
        <code class="literal">object:text-caret-moved</code>, etc.), and the
        values are functions to handle the event.  A script's
        constructor can modify/extend this dictionary by merely
        defining an entry:</p><pre class="programlisting">
self.listeners["focus:"] = self.onFocus
</pre><p>In the event there is already an entry in the
        <code class="literal">listeners</code> dictionary, it will be overridden
        by the new value.</p><p>As described previously, the
        <code class="literal">focus_tracking_presenter</code> will register
        listeners on behalf of a script, and will notify the script of
        any events via the script's
        <code class="literal">processObjectEvent</code> method.  The
        <code class="literal">processObjectEvent</code> method of the top level
        <code class="literal">Script</code> class examines the
        <code class="literal">type</code> field of the given
        <code class="literal">event</code>, calling any matching functions from
        the <code class="literal">listeners</code> dictionary.  As such, it is
        unlikely that a <code class="literal">Script</code> subclass will ever
        need to override the <code class="literal">processObjectEvent</code>
        method.  Instead, it merely needs to populate the
        <code class="literal">listeners</code> dictionary as appropriate.</p><p>The function for an event listener merely takes an
        <code class="literal">Event</code> instance (see the
        <code class="literal">atspi.py</code> module) and does whatever it
        wants; the return value is ignored.  For example, the function
        definition associated with the above
        <code class="literal">listeners</code> entry might look like the
        following, where the <code class="literal">event</code> is described
        above:</p><pre class="programlisting">
def onFocus(self, event):
    """Called whenever an object gets focus.
        
    Arguments:
    - event: the Event
    """

    ...
    orca.setLocusOfFocus(event, event.source)
    ...
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sginputeventhandlers"></a>Input Event Handlers</h2></div></div></div><p>Before describing how to set up keyboard and braille event
        handlers, it is import to first understand the
        <code class="literal">InputEventHandler</code>, which is defined in the
        <code class="literal">input_event.py</code> module.
        <code class="literal">InputEventHandler</code>s serve a purpose of
        holding a function to call for a particular input event, and a
        human consumable string that provides a short description of
        the function's behavior.  The main purpose of the
        <code class="literal">InputEventHandler</code> is to provide support for
        the "learn mode" of Orca.  If learn mode is enabled, the input
        event handler will consume the input event (i.e., return True)
        and merely speak and braille the human consumable string. If
        learn mode is not enabled, the input event handler will pass
        the active script and the input event on to the function,
        returning the boolean value of the function as indication of
        whether the event should be consumed by Orca or passed on to
        the application.</p><p>The best place to look for examples of
        <code class="literal">InputEventHandler</code>s is in the
        <code class="literal">default.py</code> module.  For example, this
        module defines an input event handler for telling the flat
        review context to move to the home position of a
        window:</p><pre class="programlisting">
reviewHomeHandler = input_event.InputEventHandler(
            Script.reviewHome,
            _("Moves flat review to the home position."))
</pre><p>In this definition, <code class="literal">default.py</code> is creating
        an <code class="literal">InputEventHandler</code> instance whose function is
        the Script's method, <code class="literal">reviewHome</code> and whose 
        human consumable text describes what will happen.  The Script's
        <code class="literal">reviewHome</code> method is defined as follows:</p><pre class="programlisting">
def reviewHome(self, inputEvent):
    """Moves the flat review context to the top left of the current
    window."""
    context = self.getFlatReviewContext()
    context.goBegin()
    self.reviewCurrentLine(inputEvent)
    self.targetCursorCell = braille.cursorCell
    return True
</pre><p>Note that the method returns <code class="literal">True</code> to
        indicate the input event has been consumed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sgkeybindings"></a>Defining Keyboard Bindings</h2></div></div></div><p>The keyboard bindings for a script are held in the
        <code class="literal">keybindings</code> field, which is a
        <code class="literal">KeyBindings</code> instance.  This field maintains
        a set of <code class="literal">KeyBinding</code> instances.</p><p>Keyboard bindings merely define the keystroke and modifier
        circumstances needed to invoke an
        <code class="literal">InputEventHandler</code> instance.  This definition
        is held in a <code class="literal">KeyBinding</code> instance (see the
        <code class="literal">keybindings.py</code> module):</p><pre class="programlisting">
self.keybindings.add(
    keybindings.KeyBinding("KP_7",
                           1 &lt;&lt; orca.MODIFIER_ORCA,
                           1 &lt;&lt; orca.MODIFIER_ORCA,
                           reviewHomeHandler))
</pre><p>The first parameter of a <code class="literal">KeyBinding</code> is
        a string that represents an X Window System KeySym string for
        the key.  This is typically a string from
        <code class="literal">/usr/include/X11/keysymdef.h</code> with the
        preceding 'XK_' removed (e.g., XK_KP_Enter becomes the string
        'KP_Enter'), and is used as a means to express the physical
        key associated with the KeySym.</p><p>The second parameter is a bit mask that defines which
        modifiers the keybinding cares about.  If it does not care
        about any modifier state, then this mask can be set to 0.  In
        the example above, the keybinding is being told to pay
        attention to the <code class="literal">MODIFIER_ORCA</code> modifier,
        which is a modifier Orca sets when the "Insert" key is
        pressed.  Other examples of modifier bit positions include
        those defined in the AT-SPI Accessibility specification:
        MODIFIER_SHIFT, MODIFIER_SHIFTLOCK, MODIFIER_CONTROL,
        MODIFIER_ALT, MODIFIER_META, MODIFIER_META2, MODIFIER_META3,
        and MODIFIER_NUMLOCK.  These can be obtained via the
        <code class="literal">orca.atspi.Accessibility</code> field.  For
        example,
        <code class="literal">orca.atspi.Accessibility.MODIFIER_SHIFTLOCK</code>.</p><p>The third parameter is a bit mask that defines what the
        modifier settings must be.  If a bit is set, it means the
        associated modifier must be set.  The only meaningful bits in
        this mask are those that are defined by the second
        parameter.  In the example above, the keybinding cares
        about the <code class="literal">MODIFIER_ORCA</code> modifier, and
        the third parameter says this modifier must be set.</p><p>The last parameter is the
        <code class="literal">InputEventHandler</code> to us if the user types a
        keystroke qualified by the previous
        parameters. <code class="literal">InputEventHandler</code>s are
        described in the previous section.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sgbraillebindings"></a>Defining Braille Bindings</h2></div></div></div><p>Refreshable braille displays have buttons that the user
        can press.  The BrlTTY system provides a means for
        standardizing the types of input events one can generate using
        these buttons, and a script can set up braille bindings to
        handle these events.</p><p>The braille bindings for a script are held in the
        <code class="literal">braillebindings</code> field, which is a
        dictionary.  The keys for the dictionary are BrlTTY constants
        representing braille input events (see
        <code class="literal">braille.py</code> for a list), and the values are
        <code class="literal">InputEventHandler</code> instances:</p><pre class="programlisting">
self.braillebindings[braille.CMD_TOP_LEFT] = reviewHomeHandler
</pre><p>In the above example, the BrlTTY
        <code class="literal">braille.CMD_TOP_LEFT</code> input event has been
        set to be handled by the same
        <code class="literal">reviewHomeHandler</code> instance described
        previously.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="sgutilities"></a>Chapter 5. Script Utilities</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#debug">Debug Utilities</a></span></dt><dt><span class="section"><a href="#sgtts">Speech Synthesis</a></span></dt><dd><dl><dt><span class="section"><a href="#sgspeechpy"><code class="literal">speech.py</code></a></span></dt><dt><span class="section"><a href="#sgsgpy"><code class="literal">speechgenerator.py</code></a></span></dt></dl></dd><dt><span class="section"><a href="#sgbrailleoutput">Braille Output</a></span></dt><dd><dl><dt><span class="section"><a href="#sgbraillepy"><code class="literal">braille.py</code></a></span></dt><dt><span class="section"><a href="#sgbgpy"><code class="literal">braillegenerator.py</code></a></span></dt></dl></dd></dl></div><p>There are many common things a script wants to do: generate
      speech, update braille, etc.  In addition, there are many common
      things a script writer wants to do, especially getting debug
      output to determine just what the AT-SPI is sending it.  This
      chapter discusses the debug utilities of Orca as well as a
      variety of utilities to assist a script in managing speech,
      braille, and magnification.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="debug"></a>Debug Utilities</h2></div></div></div><p>The debug utilities (defined in the
        <code class="literal">debug.py</code> module) of Orca provide a means
        for selectively turning on information to be sent to the
        console where Orca is running.  This information is quite
        useful in determining what is happening inside Orca as well as
        what the AT-SPI is sending to Orca.</p><p>Let's begin the discussion of the debug utilities with the
        top question on any script writer's mind: "What do I name my
        script?"  As you may recall, the name of a script is based
        upon the name of the application as given to us by the AT-SPI.
        One of the easy ways to determine this is to listen for
        <code class="literal">window:activate</code> events that will be issued
        when an application is started.  These events can then be used
        to determine the name of the application.</p><p>Fortunately, the
        <code class="literal">focus_tracking_presenter</code> already registers
        for <code class="literal">window:activate</code> events, so all you need
        to do is tell Orca to print these events out when it receives
        them.  The method for doing this involves telling the debug
        utilities what to do, and this can be done by modifying your
        <code class="literal">~/.orca/user-settings.py</code>.</p><p>There are two main settings to tell Orca to print out
        events: an event filter and an event debug level.  The event
        filter is a regular expression that is used to match AT-SPI
        event types, and the event debug level specifies a threshold
        for when to actually print information to the console (for
        more complete detail on these settings, refer to
        <code class="literal">debug.py</code>).  These settings can be modified
        by adding the following lines to your
        <code class="literal">~/.orca/user-settings.py</code>:</p><pre class="programlisting">
orca.debug.setEventDebugFilter(re.compile('window:activate'))
orca.debug.setEventDebugLevel(debug.LEVEL_OFF)
      </pre><p>Now, when you rerun Orca, it will output information
        whenever it receives a <code class="literal">window:activate</code>
        event from the AT-SPI registry.  For example, if you run Star
        Office, you should see output similar to the following:</p><pre class="programlisting">
OBJECT EVENT: window:activate detail=(0,0) 
              app='StarOffice' name='StarOffice' role='frame' 
              state='ENABLED FOCUSABLE RESIZABLE SENSITIVE SHOWING VISIBLE'
      </pre><p>The string <code class="literal">app='StarOffice'</code> indicates
        the name of the application is 'StarOffice.'  As such, if you
        wanted to write a custom script, you would call it
        <code class="literal">StarOffice.py</code>.</p><p><span class="emphasis"><em>NOTE:</em></span> you can also get other information while Orca is
        running by pressing the debug keystrokes:</p><div class="itemizedlist"><ul type="disc"><li><p>Insert+F5: dump a list of all applications to the
	      console</p></li><li><p>Insert+F6: speak/braille information about the active
	      script and application with focus</p></li><li><p>Insert+F7: dump the ancestors of the object with focus
	      to the console</p></li><li><p>Insert+F8: dump the entire widget hierarchy of the 
	      application with focus to the console</p></li></ul></div><p>The debug module also includes a number of other methods,
        each of which is described in more detail in
        <code class="literal">debug.py</code>.  Note that each method includes a
        debug level threshold.  The <code class="literal">debug.py</code> module
        has a description of various level settings and what to expect
        for output.</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">setDebugLevel(newLevel)</code>: sets the
            debug level threshold, turning on or off the various debug
            code built in to the various Orca modules.  This is
            typically called from
            <code class="literal">~/.orca/user-settings.py</code>.</p></li><li><p><code class="literal">setEventDebugLevel(newLevel)</code>:
            described above; typically called from
            <code class="literal">~/.orca/user-settings.py</code>.</p></li><li><p><code class="literal">setEventDebugFilter(regExpression)</code>:
            described above; typically called from
            <code class="literal">~/.orca/user-settings.py</code>.</p></li><li><p><code class="literal">printException(level)</code>: if an
            exception is caught, this can be used to print out detail
            about it</p></li><li><p><code class="literal">printStack(level)</code>: prints the
            current stack; useful for determining when and why a code
            path is being executed</p></li><li><p><code class="literal">println(level, text)</code>: prints the
            given text; useful for general debug output</p></li><li><p><code class="literal">printObjectEvent(level, event)</code>:
            prints out the given AT-SPI event</p></li><li><p><code class="literal">printObjectEvent(level, event)</code>:
            prints out the given AT-SPI event, using the event debug
            level as an additional threshold; this is already used by
            the <code class="literal">focus_tracking_presenter</code>, so you
            are unlikely to need it</p></li><li><p><code class="literal">printInputEvent(level, string)</code>:
            prints out the given AT-SPI event, using the event debug
            level as an additional threshold; this is already used by
            <code class="literal">orca.py</code> (for keyboard events) and
            <code class="literal">braille.py</code> (for braille events), so you
            are unlikely to need it</p></li></ul></div><p><span class="emphasis"><em>NOTE:</em></span> One debug level of interest is
        <code class="literal">debug.LEVEL_FINE</code>.  This level will tell you
        when a script is activated, and can be useful to determine if
        Orca is actually finding your script!  For example, when the
        script for the <code class="literal">gnome-terminal</code> is activated
        by the <code class="literal">focus_tracking_presenter</code>, you will
        see the following output:</p><pre class="programlisting">
ACTIVE SCRIPT: gnome-terminal (module=orca.scripts.gnome-terminal)
      </pre><p>Notice that the class of the script instance is included.
        If you determine that this class is not what you expect when
        you are developing your custom script, then something went
        wrong when trying to find or load your custom script.  This
        can often happen because Python performs a lot of late binding
        and compilation, thus errors are often not encountered until a
        specific code path is executed at run time.  You can tell the
        <code class="literal">focus_tracking_presenter</code> to give you more
        information about any possible failures or exceptions it
        handles in this area by setting the debug level to
        <code class="literal">debug.LEVEL_FINEST</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sgtts"></a>Speech Synthesis</h2></div></div></div><p>Orca provides two main modules for speech output:
      <code class="literal">speech.py</code> and
      <code class="literal">speechgenerator.py</code>. The
      <code class="literal">speech.py</code> module provides the main interface
      to the speech synthesis subsystem. The
      <code class="literal">speechgenerator.py</code> module provides a
      <code class="literal">SpeechGenerator</code> class that can be used to to
      actually generate the text to be spoken for various objects.
      The expected use of the two modules is as follows: a script will
      create its own instance of a
      <code class="literal">SpeechGenerator</code> and will use it to generate
      text.  The script will then pass this text to the
      <code class="literal">speech.py</code> module to be spoken.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sgspeechpy"></a><code class="literal">speech.py</code></h3></div></div></div><p>For the purposes of script writing, the main entry
          points of the <code class="literal">speech.py</code> module are
          <code class="literal">speak</code>,
          <code class="literal">speakUtterances</code>, and
          <code class="literal">stop</code></p><p>See the <code class="literal">speech.py</code> module for more
          information.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sgsgpy"></a><code class="literal">speechgenerator.py</code></h3></div></div></div><p>The primary goal of a <code class="literal">SpeechGenerator</code>
          is to create text to be spoken for an accessible object.
          There are two public entry points into a
          <code class="literal">SpeechGenerator</code>:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">getSpeech(obj, already_focused)</code>:
              returns a list of strings to be spoken
              for the given accessible object.  The
              <code class="literal">already_focused</code> boolean parameter
              provides a hint to the speech generator about how much
              text to generate.  For example, if a check box that
              already has focus is to be spoken, usually the reason
              for this is that the state changed between checked and
              unchecked.  As a result, an appropriate thing to do in
              this situation is to only speak the new change in
              state (e.g., "checked").</p></li><li><p><code class="literal">getSpeechContext(obj,
              stopAncestor)</code>: returns a list
              of strings to be spoken that describe the visual context
              of the given accessible object.  This is loosely
              represented by the hierarchical relationship of the
              object (i.e., the "Quit" button in the "File" menu in
              the ...), and the amount of information can be contained
              by specifying an accessible
              <code class="literal">stopAncestor</code> above which we do not
              want to know anything about.  The primary use of this
              method is to provide the user with feedback regarding
              the relevant visual context information that changed
              when the locus of focus changes, but this method is also
              useful for assisting in "where am I" queries.</p></li></ul></div><p><span class="emphasis"><em>NOTE:</em></span> Orca currently provides some level of support for
          verbosity via the <code class="literal">VERBOSITY_LEVEL</code> fields
          of the <code class="literal">settings.py</code> module.  There are
          currently two verbosity levels:
          <code class="literal">VERBOSITY_LEVEL_BRIEF</code> and
          <code class="literal">VERBOSITY_LEVEL_VERBOSE</code>.  A
          <code class="literal">SpeechGenerator</code> subclass is expected to
          examine the <code class="literal">speechVerbosityLevel</code> property
          of the <code class="literal">settings.py</code> module and provide the
          appropriate level of text:</p><pre class="programlisting">
if settings.speechVerbosityLevel == settings.VERBOSITY_LEVEL_VERBOSE:
    utterances.append(rolenames.getSpeechForRoleName(obj))
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sgbrailleoutput"></a>Braille Output</h2></div></div></div><p>Like speech, Orca provides two main modules for braille:
      <code class="literal">braille.py</code> and
      <code class="literal">braillegenerator.py</code>. The
      <code class="literal">braille.py</code> module provides the main interface
      to the braille display. The
      <code class="literal">braillegenerator.py</code> module provides a
      <code class="literal">BrailleGenerator</code> class that can be used to to
      actually generate the text to be displayed for various objects.
      The expected use of the two modules is as follows: a script will
      create its own instance of a
      <code class="literal">BrailleGenerator</code> and will use it to braille
      regions.  The script will then pass these braille regions to the
      <code class="literal">braille.py</code> module to be displayed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sgbraillepy"></a><code class="literal">braille.py</code></h3></div></div></div><p><span class="emphasis"><em>TODO:</em></span> [[[WDW - much writing to be done here, especially
          regarding how regions will provide automatic support for
          cursor routing keys.]]]</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sgbgpy"></a><code class="literal">braillegenerator.py</code></h3></div></div></div><p>The primary goal of a <code class="literal">BrailleGenerator</code>
          is to create text to be displayed for an accessible object.
          There are two public entry points into a
          <code class="literal">BrailleGenerator</code>:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">getBrailleRegions(obj,
              groupChildren=True)</code>: returns a list of two
              items: the first is an ordered list of braille
              <code class="literal">Region</code> instances that represent text
              to be displayed on the braille display, left-to-right on
              one line; and the second is an element from the first
              list that represents which <code class="literal">Region</code> has
              "focus" and should be represented by the braille cursor
              on the display.</p><p><span class="emphasis"><em>TODO:</em></span> [[[WDW - describe grouping of children.]]]</p></li><li><p><code class="literal">getBrailleContext(obj)</code>: returns
              an ordered list (i.e., an array) of braille
              <code class="literal">Region</code> instances that describe the
              visual context of the given accessible object.  This is
              loosely represented by the hierarchical relationship of
              the object (i.e., the "Quit" button in the "File" menu
              in the ...).</p></li></ul></div><p>Typically, a script will "build up" a single logical
          line of text for the braille display.  The beginning of this
          line will be the result of the call to
          <code class="literal">getBrailleContext</code> and the remainder of
          the line will be the result of one or more calls to
          <code class="literal">getBrailleRegions</code>.  Since the logical
          line will typically be longer than the number of cells on
          the braille display, the <code class="literal">braille.py</code>
          module will scroll to show the braille
          <code class="literal">Region</code> with focus.  Furthermore, the
          <code class="literal">braille.py</code> will also respond to BrlTTY
          input events to allow the user to use braille display input
          buttons for scrolling to review the entire line.</p><p><span class="emphasis"><em>NOTE:</em></span> Orca currently provides some level of support for
          verbosity via the <code class="literal">VERBOSITY_LEVEL</code> fields
          of the <code class="literal">settings.py</code> module.  There are
          currently two verbosity levels:
          <code class="literal">VERBOSITY_LEVEL_BRIEF</code> and
          <code class="literal">VERBOSITY_LEVEL_VERBOSE</code>.  A
          <code class="literal">BrailleGenerator</code> subclass is expected to
          examine the <code class="literal">brailleVerbosityLevel</code> property
          of the <code class="literal">settings.py</code> module and provide the
          appropriate level of text:</p><pre class="programlisting">
if settings.brailleVerbosityLevel == settings.VERBOSITY_LEVEL_VERBOSE:
    regions.append(braille.Region(
                   " " + rolenames.getBrailleForRoleName(obj)))
        </pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="i18n"></a>Chapter 6. Internationalization (I18N) Support</h2></div></div></div><p>All human-consumable text obtained from AT-SPI calls is
    expected to be in a localized form.  As such, Orca does not do any
    extra localization processing when working with text obtained via
    the AT-SPI.</p><p>For text generated by Orca itself, Orca handles
    internationalization and localization using
    the [<span class="citation"><a href="#gettext">gettext</a></span>] support of Python.  The
    gettext support of Python is similar to the GNU gettext module.
    Each human consumable string of Orca is US English text wrapped in
    a call to gettext.gettext.  The call to gettext.gettext will
    either return a localized string or default to the US English
    text. Orca depends upon an active and thriving community of open
    source translators to provide the localizations.</p><p>The synthesis of localized speech is to be provided by the
    underlying gnome-speech engine.  That is, Orca merely passes
    localized text to the speech engine, which is responsible for the
    correct interpretation and pronunciation.</p><p>The generation of localized braille is to be determined.
    <span class="emphasis"><em>TODO:</em></span> BrlTTY currently does not support this at the moment, but
    it is expected that the BrlTTY developers will add this in the
    future.</p></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="archbibliography"></a>Bibliography</h2></div></div></div><div class="biblioentry"><a name="at-spi"></a><p>[<span class="abbrev"><a name="at-spi.abbrev"></a>AT-SPI</span>] <span class="authorgroup"><span class="firstname">Bill</span> <span class="surname">Haneman</span>, <span class="firstname">Marc</span> <span class="surname">Mulcahy</span>, and <span class="firstname">Michael</span> <span class="surname">Meeks</span>. </span><span class="title"><i><a href="http://directory.fsf.org/accessibility/at-spi.html" target="_top">
        AT-SPI</a>
    </i>. </span></p></div><div class="biblioentry"><a name="acss"></a><p>[<span class="abbrev"><a name="acss.abbrev"></a>ACSS</span>] <span class="authorgroup"><span class="firstname">T.V.</span> <span class="surname">Raman</span>. </span><span class="title"><i><a href="http://www.w3.org/TR/1998/REC-CSS2-19980512/aural.html" target="_top">Aural Style Sheets</a>
    </i>. </span></p></div><div class="biblioentry"><a name="bonobo"></a><p>[<span class="abbrev"><a name="bonobo.abbrev"></a>Bonobo</span>] <span class="author"><span class="firstname">George</span> <span class="surname">Lebl</span>. </span><span class="title"><i><a href="http://lidn.sourceforge.net/articles/gnomenclatureintrotobonobo/" target="_top">
        Gnomenclature: Intro to bonobo</a>
    </i>. </span></p></div><div class="biblioentry"><a name="brltty"></a><p>[<span class="abbrev"><a name="brltty.abbrev"></a>BRLTTY</span>] <span class="authorgroup"><span class="firstname">Dave</span> <span class="surname">Meilke</span>, <span class="firstname">Nicolas</span> <span class="surname">Pitre</span>, and <span class="firstname">Stephane</span> <span class="surname">Doyon</span>. </span><span class="title"><i><a href="http://directory.fsf.org/accessibility/brltty.html" target="_top">
        BRLTTY</a>
    </i>. </span></p></div><div class="biblioentry"><a name="emacspeak"></a><p>[<span class="abbrev"><a name="emacspeak.abbrev"></a>Emacspeak</span>] <span class="authorgroup"><span class="firstname">T.V.</span> <span class="surname">Raman</span>. </span><span class="title"><i><a href="http://emacspeak.sourceforge.net/" target="_top">Emacspeak</a>
    </i>. </span></p></div><div class="biblioentry"><a name="gail"></a><p>[<span class="abbrev"><a name="gail.abbrev"></a>GAIL</span>] <span class="author"><span class="firstname">Bill</span> <span class="surname">Haneman</span>. </span><span class="title"><i><a href="http://freshmeat.net/projects/gail/" target="_top">
        GAIL</a>
    </i>. </span></p></div><div class="biblioentry"><a name="gettext"></a><p>[<span class="abbrev"><a name="gettext.abbrev"></a>gettext</span>] <span class="author"><span class="surname"><span class="emphasis"><em>TODO:</em></span> Unknown</span>. </span><span class="title"><i><a href="http://docs.python.org/lib/module-gettext.html" target="_top">
        gettext</a>
    </i>. </span></p></div><div class="biblioentry"><a name="gnome-mag"></a><p>[<span class="abbrev"><a name="gnome-mag.abbrev"></a>gnome-mag</span>] <span class="author"><span class="firstname">Bill</span> <span class="surname">Haneman</span>. </span><span class="title"><i><a href="http://directory.fsf.org/accessibility/gnome-mag.html" target="_top">
        gnome-mag</a>
    </i>. </span></p></div><div class="biblioentry"><a name="gnome-speech"></a><p>[<span class="abbrev"><a name="gnome-speech.abbrev"></a>gnome-speech</span>] <span class="authorgroup"><span class="firstname">Marc</span> <span class="surname">Mulcahy</span> and <span class="firstname">Michael</span> <span class="surname">Meeks</span>. </span><span class="title"><i><a href="http://directory.fsf.org/accessibility/gnome-speech.html" target="_top">
        gnome-speech</a>
    </i>. </span></p></div><div class="biblioentry"><a name="gnopernicus"></a><p>[<span class="abbrev"><a name="gnopernicus.abbrev"></a>Gnopernicus</span>] <span class="author"><span class="firstname">Remus</span> <span class="surname">Draica</span>. </span><span class="title"><i><a href="http://directory.fsf.org/accessibility/gnopernicus.html" target="_top">
        Gnopernicus</a>
    </i>. </span></p></div><div class="biblioentry"><a name="jaws"></a><p>[<span class="abbrev"><a name="jaws.abbrev"></a>JAWS</span>] <span class="author"><span class="firstname"></span> <span class="surname">Freedom Scientific</span>. </span><span class="title"><i><a href="http://www.freedomscientific.com/fsproducts/softwarejaws.asp" target="_top">
        JAWS</a>
    </i>. </span></p></div><div class="biblioentry"><a name="xkb"></a><p>[<span class="abbrev"><a name="xkb.abbrev"></a>XKB</span>] <span class="authorgroup"><span class="firstname">Erik</span> <span class="surname">Fortune</span>, <span class="firstname">William</span> <span class="surname">Walker</span>, <span class="firstname">Donna</span> <span class="surname">Converse</span>, and <span class="firstname">George</span> <span class="surname">Sachs</span>. </span><span class="title"><i><a href="http://matrix.netsoc.tcd.ie/hcksplat/work/XKBlib.pdf" target="_top">
        The XKB keyboard extension</a>
    </i>. </span></p></div></div></div></body></html>
